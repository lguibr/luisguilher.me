File: .editorconfig
""""""
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
""""""


File: .eslintignore
""""""
node_modules
.next
""""""


File: .eslintrc.json
""""""
{
  "env": {
    "browser": true,
    "es2021": true,
    "node": true,
    "jest": true
  },
  "extends": [
    "plugin:react/recommended",
    "standard",
    "plugin:@typescript-eslint/recommended",
    "plugin:@next/next/recommended",
    "prettier"
  ],
  "settings": {
    "react": {
      "version": "detect"
    }
  },
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    },
    "ecmaVersion": 12,
    "sourceType": "module"
  },
  "plugins": ["react", "@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "react/prop-types": "off",
    "space-before-function-paren": "off",
    "react/react-in-jsx-scope": "off"
  }
}
""""""


File: .gitignore
""""""
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.husky

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel
""""""


File: .nvmrc
""""""
v16.20.2
""""""


File: README.md
""""""

Welcome to [luisguilher.me](https://luisguilher.me), an immersive web experience showcasing my professional portfolio through an interactive interface inspired by the VS Code IDE. This project demonstrates modern front-end development skills and provides a unique way to explore my resume, skills, and projects.

## Features

-   **VS Code-like Interface**: Offers a familiar and intuitive environment simulating the popular VS Code IDE.
-   **Welcome Tour**: Guides users through the features interactively.
-   **Self-Hosted Source Code**: Allows code exploration directly within the interface, similar to an IDE.
-   **Multiple File Viewing**: Supports opening and working with multiple files simultaneously with a split-screen feature.
-   **Drag and Drop**: Facilitates easy organization of file views within the workspace.
-   **Text Search**: Enables quick searching for text across all open (and modified) files.
-   **Diff Comparison**: Allows users to track changes and view differences between current and original files in the "Source Control" view.
-   **Interactive Canvas Animations**: Adds visual interest during file loading and when interacting with specific UI elements (e.g., Extensions menu).
-   **Extensive Canvas Collection**: Offers a range of animations accessible through the extensions menu.
-   **Print-Ready CV**: Generate a formatted CV using the shortcut `Ctrl+P`.
-   **Theme Customization**: Personalize the interface with light and dark themes (`Ctrl+Q`).

## Technologies Used

-   **Front-end Frameworks/Libraries**: React, Next.js
-   **TypeScript**: Ensures type safety across the project.
-   **Styled Components**: Manages component-level styles and theming. ([See Styling README](./src/styles/README.md))
-   **Monaco Editor**: Provides the core code editor functionality.
-   **P5.js**: Powers the interactive canvas animations. ([See Sketches README](./src/components/Core/Sketchs/README.md))
-   **React Resizable Panels**: Enables splittable view layouts.
-   **Reactour**: Drives the interactive welcome guide.
-   **Deployment**: Hosted on Vercel with Analytics.

## Data Structures & State Management

-   **Tree of Files**: A hierarchical structure representing the file system (both resume data and project source code), managed within `FileContext`. ([See Contexts README](./src/contexts/README.md))
-   **Binary Tree of Views**: Manages the layout and state (opened files, current file) of potentially split editor panes, managed within `FileViewsContext`. ([See Contexts README](./src/contexts/README.md))
-   **React Context API & `useReducer`**: Used extensively for global state management (Files, Views, Theme, Loading, etc.). ([See Contexts README](./src/contexts/README.md), [Reducers README](./src/reducers/README.md))

## Installation

To run `luisguilher.me` locally:

1.  Clone the repository:
    ```bash
    git clone https://github.com/lguibr/luisguilher.me.git
    ```
2.  Navigate to the project directory:
    ```bash
    cd luisguilher.me
    ```
3.  Install dependencies:
    ```bash
    yarn install
    ```
4.  Start the development server:
    ```bash
    yarn dev
    ```

Visit `http://localhost:3000` in your browser.

## Usage Shortcuts

-   **Toggle Theme**: `Ctrl + Q`
-   **Print/Download Resume**: `Ctrl + P`
-   **Restart Tour**: `Ctrl + Shift + 2` (or `Ctrl + @`)
-   **Flash Loading Animation**: `Ctrl + Space`

## Project Structure

```
luisguilher.me/
│
├── public/             # Static assets (icons, images)
│
├── src/
│   ├── assets/         # Static data (contacts, resume sections)
│   ├── components/     # React components ([README](./src/components/README.md))
│   │   ├── Core/       # Reusable UI/logic components ([README](./src/components/Core/README.md))
│   │   └── Home/       # Components specific to the main IDE layout
│   ├── contexts/       # React Context providers ([README](./src/contexts/README.md))
│   ├── hooks/          # Custom React hooks ([README](./src/hooks/README.md))
│   ├── pages/          # Next.js page routes
│   ├── reducers/       # State reducer functions ([README](./src/reducers/README.md))
│   ├── services/       # External API interactions ([README](./src/services/README.md))
│   └── styles/         # Global styles, themes, type definitions ([README](./src/styles/README.md))
│
├── .editorconfig       # Editor configuration
├── .eslintrc.json      # ESLint configuration
├── .gitignore          # Git ignore rules
├── next.config.js      # Next.js configuration
├── package.json        # Project dependencies and scripts
├── README.md           # This file
├── tsconfig.json       # TypeScript configuration
└── yarn.lock           # Dependency lock file
```

## Contributing

Contributions are welcome!

1.  Fork the repository.
2.  Create a new branch (`git checkout -b feature/your-feature`).
3.  Make your changes.
4.  Commit your changes (`git commit -m 'Add some feature'`).
5.  Push to the branch (`git push origin feature/your-feature`).
6.  Open a Pull Request.

Please ensure your code adheres to the existing linting rules (`yarn lint`).

## License

This project is open-source under the MIT License.

## Final Note

Thank you for visiting `luisguilher.me`. Explore, interact, and feel free to connect!
""""""


File: next-env.d.ts
""""""
/// <reference types="next" />
/// <reference types="next/types/global" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
""""""


File: next.config.js
""""""
/** @type {import('next').NextConfig} */

module.exports = {
  env: {
    REPO: 'luisguilher.me',
    OWNER: 'lguibr',
    SHA_BRANCH: 'main',
    RESUME: 'resume'
  },
  reactStrictMode: true,
  webpack(config) {
    config.module.rules.push({
      test: /\.svg$/,
      use: ['@svgr/webpack']
    })
    config.module.rules.push({
      test: /\.md$/,
      use: ['raw-loader']
    })
    return config
  }
}
""""""


File: package.json
""""""
{
  "name": "luisguilher.me",
  "version": "0.2.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint && prettier --write ./src",
    "lint:hook": "eslint --fix ./src && pretty-quick --staged"
  },
  "engines": {
    "node": "16.x"
  },
  "husky": {
    "hooks": {
      "pre-commit": "yarn lint:hook"
    }
  },
  "dependencies": {
    "@monaco-editor/react": "^4.2.2",
    "@svgr/core": "^5.5.0",
    "@types/p5": "^1.3.0",
    "@types/reactour": "^1.18.2",
    "@types/yaml": "^1.9.7",
    "@vercel/analytics": "^1.2.2",
    "next": "11.1.0",
    "p5": "^1.4.0",
    "raw-loader": "^4.0.2",
    "react": "17.0.2",
    "react-dom": "17.0.2",
    "react-resizable-panels": "^2.0.16",
    "react-to-print": "^2.13.0",
    "reactour": "^1.18.6",
    "sharp": "^0.29.0",
    "styled-components": "^5.3.0",
    "yaml": "^1.10.2"
  },
  "devDependencies": {
    "@svgr/webpack": "^5.5.0",
    "@types/react": "17.0.17",
    "@types/styled-components": "^5.1.12",
    "@typescript-eslint/eslint-plugin": "^4.29.1",
    "@typescript-eslint/parser": "^4.29.1",
    "eslint": "^7.32.0",
    "eslint-config-next": "11.1.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-config-standard": "^16.0.3",
    "eslint-plugin-import": "^2.24.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^3.4.0",
    "eslint-plugin-promise": "^5.1.0",
    "eslint-plugin-react": "^7.24.0",
    "husky": "^7.0.2",
    "prettier": "^2.3.2",
    "pretty-quick": "^3.1.1",
    "typescript": "4.3.5"
  }
}
""""""


File: prettier.config.js
""""""
module.exports = {
  semi: false,
  singleQuote: true,
  arrowParens: 'avoid',
  endOfLine: 'auto',
  trailingComma: 'none'
}
""""""


File: src/assets/contacts.ts
""""""
export default {
  'WhatsApp/Phone': '+55 37991640818',
  Email: 'lgpelin92@gmail.com',
  LinkedIn: 'https://www.linkedin.com/in/lguibr/',
  GitHub: 'https://github.com/lguibr',
  Website: 'https://luisguilher.me'
}
""""""


File: src/assets/coverLetter.ts
""""""
export default [
  `Hi there,
I'm Luís Guilherme, a seasoned full-stack developer with over eight years of delivering robust and dynamic applications. My expertise spans TypeScript, React, Python, Go, and serverless technologies, enabling me to tackle projects ranging from breweries to traceability and crypto systems with efficiency and scalability.
My passion for AI and decentralized technologies drives me to integrate these innovations into my work. For instance, CommitAI, a tool I developed, leverages AI language models like GPT-4 and Claude to generate meaningful commit messages from branch names, git diffs, and commit message templates, significantly improving our development workflow. Creating a Terraform CDK and TypeScript-based API bootstrap for serverless web applications exemplifies my initiative in automating cloud resource provisioning.
My technical acumen extends to game development with Pongo, a Pong and Breakout-inspired game that showcases my proficiency in Go through the Actor Model pattern. I've developed a CLI project generator in Python that streamlines project initiation with integrated CI/CD pipelines, linting and PyPI publishing.
Outside of programming, my fascination with physics and my time with my cats often inspire innovative approaches and solutions in my projects. I value collaboration, clear communication, and a problem-solving mindset, believing these are crucial for achieving outstanding results in any team endeavor.
I am eager to contribute my skills and passion to your team. I aim to push the boundaries of what's possible in web development and create impactful projects together.
Thank you for contacting me. I'm looking forward to discussing how I can contribute to the success of our future team.`
]
""""""


File: src/assets/education.ts
""""""
export default [
  {
    School: 'Universidade Federal de Minas Gerais',
    Degree: 'Bachelor of Physics',
    Dates: '2018 – 2022'
  },
  {
    School: 'Centro Federal de Educação Tecnológica de Minas Gerais',
    Degree: 'Technical Information Technology ',
    Dates: '2006 – 2008'
  }
]
""""""


File: src/assets/experiences.ts
""""""
const experiences = [
  {
    Company: 'Paradigm',
    Role: 'Software Engineer Full Time',
    Start_at: 'Apr 2022',
    End_at: 'Apr 2024',
    Description: `As a Software Engineer at Paradigm, I spearheaded the development of unified UI interfaces using React, React Native, and Electron. By consolidating single-source code, I enhanced user experience and consistency across platforms, increasing team productivity. I also led the implementation of end-to-end testing for complex web crypto applications using Playwright in Python while tackling backend challenges with Golang.`,
    Techs:
      'TypeScript, Python, Go, Electron, React.js, Selenium, Playwright, Docker, Django, AWS, Terraform, Kubernetes, Kafka, Redis .'
  },
  {
    Company: 'Trio',
    Role: 'Senior Software Engineer Full Time',
    Start_at: 'Jun 2021',
    End_at: 'Apr 2022',
    Description:
      "As a Senior Software Engineer at Trio, I was a technical leader in NodeJS application projects. I was responsible for task preparation, cloud resource provisioning, code reviews, and guiding developers. By ensuring code style and quality, I contributed to successfully delivering large-scale projects for major clients in the brewery and traceability industries. As a full-stack software engineer, I played a critical role in driving these projects' technical direction and implementation.",
    Techs:
      'Typescript, VueJS, NextJS, React, Electron, KoaJS, ExpressJS, GraphQL, Strapi, PostgreSQL, MySQL, Redis, Webpack, Babel, GCP, Google Cloud Functions, Big Query, Terraform'
  },
  {
    Company: 'Trio',
    Role: 'Software Engineer Full Time',
    Start_at: 'May 2020',
    End_at: 'Jun 2021',
    Description:
      "As a Software Engineer at Trio, I acted as a technical leader in multiple projects for various clients. I defined technology stacks, provisioned resources in the cloud, implemented code, instructed other developers, and reviewed code to ensure quality. I also collaborated directly with Trio's clients to align expectations and high-level requirements. My leadership and technical expertise were instrumental in delivering successful projects and maintaining strong client relationships.",
    Techs:
      'Typescript, React, Vue, NextJS, Electron, Express, Koa, Strapi, GraphQL, MySQL, PostgreSQL, Redis, GCP Functions, GCP BigQuery, AWS S3, Heroku'
  },
  {
    Company: 'TremTec',
    Role: 'Software Engineer Full Time',
    Start_at: 'Jul 2019',
    End_at: 'May 2020',
    Description: `As a Software Engineer at TremTec, I have headed the Front-End team and worked on multiple parallel projects for different clients. I collaborated with the clients' Product Owners to define functional and technical solutions and implemented code to bring those solutions to life. My role involved effective communication, problem-solving, and delivering high-quality software solutions meeting clients' requirements.`,
    Techs: 'Typescript, React, GraphQL, Docker'
  },
  {
    Company: 'netLex',
    Role: 'Software Engineer Full Time',
    Start_at: 'Jul 2018',
    End_at: 'May 2019',
    Description: `At netLex, I worked as a Full Stack Developer on the development of a platform for managing legal documents and their lifecycle. I actively participated in the functional and technical definition, implementation, and cloud provisioning of features.`,
    Techs:
      'Javascript, PHP, Python, Docker, AWS EC2, AWS S3, MySQL, Laravel, Flask, AngularJS'
  },
  {
    Company: 'Editora Ecológica',
    Role: 'IT auxiliary Full Time',
    Start_at: 'May 2008',
    End_at: 'Dec 2010',
    Description: `In my role as an IT Auxiliary at Editora Ecológica, I was responsible for maintaining the publisher's virtual store. I created advertising pieces that were published on the website and sent through email campaigns. By leveraging my skills in web technologies, I ensured the smooth operation of the virtual store and effectively promoted the publisher's products.`,
    Techs: 'Javascript, PHP, JQuery, HTML, CSS, FTP'
  }
]
const calculateDuration = (startDate: string, endDate: string): string => {
  const start = new Date(startDate)
  const end = endDate === 'Present' ? new Date() : new Date(endDate)

  const diffInMonths =
    (end.getFullYear() - start.getFullYear()) * 12 +
    (end.getMonth() + 1 - start.getMonth())

  const years = Math.floor(diffInMonths / 12)
  const months = diffInMonths % 12

  let duration = ''
  if (years > 0) {
    duration += `${years} yr${years > 1 ? 's' : ''} `
  }
  if (months > 0) {
    duration += `${months} mo${months > 1 ? 's' : ''}`
  }

  return duration.trim()
}

export default experiences.map(experience => {
  return {
    ...experience,
    Duration: calculateDuration(experience.Start_at, experience.End_at)
  }
})
""""""


File: src/assets/projects.ts
""""""
type Project = {
  name: string
  description: string
  technologies: string
  url?: string
  repository?: string
}

const projects: Project[] = [
  {
    name: 'luisguilher.me',
    url: 'https://luisguilher.me',
    description:
      'The personal website, resume, and CV of Luis Guilherme. The website is built using Next.js, a powerful React framework, with TypeScript for static type checking. The site features a unique presentation of code using the Monaco Editor, which is the same editor used in Visual Studio Code.',
    technologies: 'React, TypeScript, NextJS, Styled Components, P5js',
    repository: 'https://github.com/lguibr/luisguilher.me'
  },
  {
    name: 'MimeFlow',
    url: 'https://mimeflow.luisguilher.me',
    description:
      "MimeFlow the pose matching application lets you engage interactively to practice and perfect your poses across various disciplines, from dance to martial arts, and yoga. Powered by cutting-edge technology, it's designed to adapt to your skills, helping you refine your movements with precision.",
    technologies:
      'TensorFlow, Typescript, NextJS, WebGL, P5js, BlazePose, Linear Algebra',
    repository: 'https://github.com/lguibr/mimeflow'
  },
  {
    name: 'CommitAI',
    url: 'https://pypi.org/project/commitai/',
    description:
      'CommitAI is a command-line tool that helps you generate informative and relevant commit messages for your Git repositories using GPT-4 by OpenAI. It analyzes your staged changes, combines it with a high-level explanation provided by you, and creates a commit message based on this information.',
    technologies: 'Python, AI, LLM, GPT, Claude, Git',
    repository: 'https://github.com/lguibr/commitai'
  },
  {
    name: 'Pongo',
    description:
      'This game combines elements of the classic Pong game with the gameplay of breaking brick games. The backend of the game is written in Go and utilizes the Actor Model pattern to handle different game elements, such as player input, game state, paddle movement, and ball movement. The game has zero dependencies.',
    technologies: 'Go, WebSockets',
    repository: 'https://github.com/lguibr/pongo'
  },
  {
    name: 'Terraplain',
    description:
      'A bootstrap to API with automated provisioning of cloud resources in Google Cloud Platform using Terraform CDK in Typescript.',
    technologies: 'Terraform, Google Cloud Platform, Big Query, TypeScript',
    repository: 'https://github.com/lguibr/terraplain'
  }
]

export default projects
""""""


File: src/assets/sketchMetadata.ts
""""""
// src/assets/sketchMetadata.ts

// Metadata for UI listing
export const sketchs = [
  // Removed Bouncing entry
  {
    name: 'LinearConservation',
    description: 'A single body bouncing with linear momentum conservation.',
    icon: '/icons/linear.png'
  },
  {
    name: 'SnowFlakes',
    description: 'Cute snowflakes falling from the sky.',
    icon: '/icons/snow.png'
  },
  {
    name: 'DoublePendulum',
    description:
      'Simulates the chaotic motion of a double pendulum with trace.',
    icon: '/icons/pendulum.png'
  },
  {
    name: 'HexagonCollision',
    description:
      'Spinning hexagons release triangles that collide elastically.',
    icon: '/icons/hexagon.png'
  },
  {
    name: 'Starfield',
    description:
      'Simulates a starfield effect like hyperspace travel using Google colors.', // Updated description
    icon: '/icons/starfield.png'
  },
  {
    name: 'PathfindingMaze',
    description: 'Visualizes the A* pathfinding algorithm in a random maze.',
    icon: '/icons/maze.png'
  },
  {
    name: 'Hypercube',
    description: 'Renders a rotating 4D hypercube (tesseract) in 3D space.',
    icon: '/icons/hypercube.png'
  },
  {
    name: 'GoogleFlowField',
    description:
      'Particles moving along a Perlin noise flow field using Google colors.',
    icon: '/icons/flowfield.png'
  },
  {
    name: 'BoidsSimulation',
    description: 'Simulates flocking behavior (boids) using Google colors.',
    icon: '/icons/boids.png'
  },
  {
    name: 'GameOfLife',
    description: "Conway's Game of Life simulation with Google colors.",
    icon: '/icons/gol.png'
  },
  {
    name: 'Metaballs',
    description: 'Generates a gooey metaball effect using Google colors.',
    icon: '/icons/metaballs.png'
  },
  {
    name: 'FourierDrawing',
    description: 'Draws shapes using epicycles based on Fourier series.',
    icon: '/icons/fourier.png'
  }
  // Removed ReactionDiffusion entry
]

export default sketchs // Also add default export for flexibility if needed later
""""""


File: src/assets/skills.ts
""""""
export default [
  {
    Languages: [
      "name: 'Portuguese',             rating: '10/10', since: 1992",
      "name: 'English',                rating: '8/10',  since: 2004"
    ]
  },
  {
    'Programming Languages': [
      "name: 'JavaScript',             rating: '9/10',  since: 2008",
      "name: 'PHP',                    rating: '8/10',  since: 2008",
      "name: 'TypeScript',             rating: '9/10',  since: 2017",
      "name: 'Python',                 rating: '8/10',  since: 2018",
      "name: 'Go',                     rating: '7/10',  since: 2022"
    ]
  },
  {
    'Development Tools': [
      "name: 'Linux',                  rating: '8/10',  since: 2016",
      "name: 'Git',                    rating: '9/10',  since: 2016",
      "name: 'Node.js',                rating: '9/10',  since: 2016"
    ]
  },
  {
    'Front-end': [
      "name: 'React',                  rating: '9/10',  since: 2018",
      "name: 'Electron',               rating: '8/10',  since: 2018",
      "name: 'React Native',           rating: '7/10',  since: 2018",
      "name: 'JS Bundlers',            rating: '7/10',  since: 2018",
      "name: 'Redux',                  rating: '7/10',  since: 2019",
      "name: 'Vue',                    rating: '6/10',  since: 2020",
      "name: 'Websocket',              rating: '7/10',  since: 2020",
      "name: 'GraphQL',                rating: '7/10',  since: 2020"
    ]
  },
  {
    'Back-end': [
      "name: 'JS Frameworks',          rating: '9/10',  since: 2019",
      "name: 'Python Frameworks',      rating: '8/10',  since: 2019",
      "name: 'Redis',                  rating: '7/10',  since: 2019",
      "name: 'SQL',                    rating: '8/10',  since: 2019",
      "name: 'NoSQL',                  rating: '6/10',  since: 2020",
      "name: 'Kafka',                  rating: '6/10',  since: 2023",
      "name: 'Nat',                    rating: '6/10',  since: 2023",
      "name: 'GRpc',                   rating: '6/10',  since: 2023"
    ]
  },
  {
    'Testing/QA': [
      "name: 'Jest',                   rating: '8/10',  since: 2019",
      "name: 'PyTest',                 rating: '7/10',  since: 2019",
      "name: 'Selenium',               rating: '7/10',  since: 2021",
      "name: 'Playwright',             rating: '8/10',  since: 2022"
    ]
  },
  {
    'Cloud/Infrastructure': [
      "name: 'Docker',                 rating: '8/10',  since: 2018",
      "name: 'AWS',                    rating: '6/10',  since: 2019",
      "name: 'Google Cloud',           rating: '7/10',  since: 2021",
      "name: 'Terraform',              rating: '7/10',  since: 2021",
      "name: 'Kubernetes',             rating: '6/10',  since: 2023"
    ]
  }
]
""""""


File: src/components/Core/AnimationOverlay/index.tsx
""""""
import React, { useEffect, useRef, useState, useCallback } from 'react'
import { useTheme } from 'styled-components'
import { Overlay, CanvasContainer, StatusMessage } from './styled'
import type { SketchFactory } from 'src/components/Core/Sketchs'
import theme from 'src/styles/theme'
import type P5 from 'p5'

// --- Manual Imports for Sketch Factories ---
// Removed BouncingSketch import
import LinearConservationSketch from 'src/components/Core/Sketchs/LinearConservation'
import SnowFlakesSketch from 'src/components/Core/Sketchs/SnowFlakes'
import DoublePendulumSketch from 'src/components/Core/Sketchs/DoublePendulum'
import HexagonCollisionSketch from 'src/components/Core/Sketchs/HexagonCollision'
import StarfieldSketch from 'src/components/Core/Sketchs/Starfield'
import PathfindingMazeSketch from 'src/components/Core/Sketchs/PathfindingMaze'
import HypercubeSketch from 'src/components/Core/Sketchs/Hypercube'
import GoogleFlowFieldSketch from 'src/components/Core/Sketchs/GoogleFlowField'
import BoidsSimulationSketch from 'src/components/Core/Sketchs/BoidsSimulation'
import GameOfLifeSketch from 'src/components/Core/Sketchs/GameOfLife'
import MetaballsSketch from 'src/components/Core/Sketchs/Metaballs'
import FourierDrawingSketch from 'src/components/Core/Sketchs/FourierDrawing'
// Removed ReactionDiffusionSketch import
// --- End Manual Imports ---

type Theme = typeof theme['vs-dark']

// --- Map Sketch Names to Imported Factories ---
const sketchFactoryMap: { [key: string]: SketchFactory } = {
  // Removed Bouncing entry
  LinearConservation: LinearConservationSketch,
  SnowFlakes: SnowFlakesSketch,
  DoublePendulum: DoublePendulumSketch,
  HexagonCollision: HexagonCollisionSketch,
  Starfield: StarfieldSketch,
  PathfindingMaze: PathfindingMazeSketch,
  Hypercube: HypercubeSketch,
  GoogleFlowField: GoogleFlowFieldSketch,
  BoidsSimulation: BoidsSimulationSketch,
  GameOfLife: GameOfLifeSketch,
  Metaballs: MetaballsSketch,
  FourierDrawing: FourierDrawingSketch
  // Removed ReactionDiffusion entry
}
// --- End Map ---

interface AnimationOverlayProps {
  sketchName: string | null
  onClose: () => void
}

const AnimationOverlay: React.FC<AnimationOverlayProps> = ({
  sketchName,
  onClose
}) => {
  const currentTheme = useTheme()
  const p5InstanceRef = useRef<P5 | null>(null)
  const containerRef = useRef<HTMLDivElement | null>(null)
  const [error, setError] = useState<string | null>(null)
  const resizeObserverRef = useRef<ResizeObserver | null>(null)
  const resizeTimeoutIdRef = useRef<NodeJS.Timeout | null>(null)

  const cleanupP5 = useCallback(() => {
    console.log(
      `[AnimationOverlay Cleanup] Cleaning up P5 for ${sketchName}...`
    )
    if (resizeTimeoutIdRef.current) {
      clearTimeout(resizeTimeoutIdRef.current)
      resizeTimeoutIdRef.current = null
    }
    if (resizeObserverRef.current) {
      if (containerRef.current) {
        try {
          resizeObserverRef.current.unobserve(containerRef.current)
        } catch (e) {
          console.error('[AnimationOverlay Cleanup] Error unobserving:', e)
        }
      }
      try {
        resizeObserverRef.current.disconnect()
      } catch (e) {
        console.error(
          '[AnimationOverlay Cleanup] Error disconnecting observer:',
          e
        )
      }
      resizeObserverRef.current = null
    }
    if (p5InstanceRef.current) {
      try {
        p5InstanceRef.current.remove()
        console.log(`[AnimationOverlay Cleanup] P5 instance removed.`)
      } catch (removeError) {
        console.error(
          '[AnimationOverlay Cleanup] Error during p5 remove():',
          removeError
        )
      }
      p5InstanceRef.current = null
    }
    setError(null)
  }, [sketchName])

  useEffect(() => {
    console.log(
      `[AnimationOverlay useEffect] Running for sketchName prop: ${sketchName}`
    )

    if (!sketchName || !containerRef.current) {
      if (!sketchName) {
        console.log(
          '[AnimationOverlay useEffect] Aborting: No sketch name provided.'
        )
        // Don't set error if just closing
        // setError('No sketch name provided.');
      }
      if (!containerRef.current) {
        console.log(
          '[AnimationOverlay useEffect] Aborting: Canvas container not ready.'
        )
        setError('Canvas container not ready.')
      }
      return
    }

    const factory = sketchFactoryMap[sketchName]
    if (!factory) {
      console.error(
        `[AnimationOverlay useEffect] Aborting: Sketch factory for "${sketchName}" not found.`
      )
      setError(`Sketch factory for "${sketchName}" not found.`)
      return
    }

    let isMounted = true
    setError(null)

    const initialize = async () => {
      let P5Constructor: typeof P5 | null = null
      try {
        console.log('[AnimationOverlay initialize] Dynamically importing P5...')
        P5Constructor = (await import('p5')).default
        if (!isMounted || !containerRef.current) {
          console.log(
            '[AnimationOverlay initialize] Aborting after P5 import: Unmounted or container gone.'
          )
          return
        }
        console.log('[AnimationOverlay initialize] P5 imported successfully.')

        console.log(
          `[AnimationOverlay initialize] Creating P5 instance for: ${sketchName}...`
        )
        const sketchFunction = factory(currentTheme as Theme)
        const instance = new P5Constructor(sketchFunction, containerRef.current)
        p5InstanceRef.current = instance
        console.log(
          `[AnimationOverlay initialize] P5 instance CREATED successfully for: ${sketchName}`
        )

        const resizeCanvas = () => {
          if (p5InstanceRef.current && containerRef.current) {
            // Use window dimensions for full screen effect
            const clientWidth = window.innerWidth
            const clientHeight = window.innerHeight
            if (clientWidth > 0 && clientHeight > 0) {
              try {
                p5InstanceRef.current.resizeCanvas(clientWidth, clientHeight)
                if (typeof p5InstanceRef.current.windowResized === 'function') {
                  p5InstanceRef.current.windowResized()
                }
              } catch (resizeError) {
                console.error(
                  '[AnimationOverlay resizeCanvas] Error during canvas resize:',
                  resizeError
                )
              }
            }
          }
        }
        // Initial resize and observer setup
        resizeTimeoutIdRef.current = setTimeout(resizeCanvas, 50)
        resizeObserverRef.current = new ResizeObserver(resizeCanvas)
        // Observe window resize instead of container for full screen
        window.addEventListener('resize', resizeCanvas)
        console.log(
          `[AnimationOverlay initialize] Resize listener added for ${sketchName}.`
        )
      } catch (err: any) {
        console.error(
          `[AnimationOverlay initialize] CRITICAL Error initializing sketch "${sketchName}":`,
          err
        )
        if (isMounted) {
          setError(`Failed to initialize sketch: ${err.message}`)
        }
        cleanupP5()
      }
    }

    initialize()

    return () => {
      isMounted = false
      // Remove window resize listener on cleanup
      if (resizeObserverRef.current) {
        window.removeEventListener('resize', () => {
          /* no-op */
        }) // Ensure correct listener removal if needed
      }
      cleanupP5()
    }
  }, [sketchName, currentTheme, cleanupP5])

  if (!sketchName) return null

  return (
    <Overlay
      onClick={e => {
        // Close only if clicking the overlay background itself
        if (e.target === e.currentTarget) {
          onClose()
        }
      }}
    >
      {/* Add onClick to CanvasContainer to close when clicking the sketch */}
      <CanvasContainer ref={containerRef} onClick={onClose}>
        {error && <StatusMessage>Error: {error}</StatusMessage>}
      </CanvasContainer>
    </Overlay>
  )
}

export default AnimationOverlay
""""""


File: src/components/Core/AnimationOverlay/styled.ts
""""""
import styled from 'styled-components'

export const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  background-color: rgba(0, 0, 0, 0); /* Fully transparent background */
  cursor: pointer; /* Indicate clicking closes it */
`

export const CanvasContainer = styled.div`
  width: 100%; /* Take full overlay size */
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  position: relative; /* For potential loading/error messages */
  cursor: pointer; /* Allow clicking the canvas area to close */

  canvas {
    display: block;
    max-width: 100%;
    max-height: 100%;
    /* Removed border-radius and box-shadow */
  }
`

export const StatusMessage = styled.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: ${({ theme }) => theme.colors.white};
  background-color: rgba(0, 0, 0, 0.7);
  padding: 10px 20px;
  border-radius: 5px;
  font-size: 1.2em;
`
""""""


File: src/components/Core/Canvas/index.tsx
""""""
import React, { useEffect, useRef, useState } from 'react'
import { Container, Canvas } from './styled'
import { useTheme } from 'styled-components'
import theme from 'src/styles/theme'
import type { SketchFactory } from 'src/components/Core/Sketchs'
import type P5 from 'p5' // Import P5 type only

type Theme = typeof theme['vs-dark']

interface CanvasProps {
  sketchCanvas?: SketchFactory
}

const CanvasComponent: React.FC<CanvasProps> = ({ sketchCanvas }) => {
  const p5Ref = useRef<HTMLDivElement | null>(null)
  const parentRef = useRef<HTMLDivElement | null>(null)
  const p5InstanceRef = useRef<P5 | null>(null) // Use ref for instance
  const currentTheme = useTheme()

  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })

  // Effect to create P5 instance
  useEffect(() => {
    let isMounted = true // Track mount status

    const initializeP5 = async () => {
      // Only create instance if a sketch factory is provided and refs are available
      if (sketchCanvas && parentRef?.current && p5Ref?.current && isMounted) {
        try {
          console.log('[CanvasComponent] Dynamically importing P5...')
          const P5 = (await import('p5')).default // Dynamic import
          console.log('[CanvasComponent] P5 imported.')

          if (!p5Ref.current || !isMounted) {
            console.log(
              '[CanvasComponent] Ref gone or unmounted before P5 creation.'
            )
            return
          }

          const sketchFunction = sketchCanvas(currentTheme as Theme)
          const instance = new P5(sketchFunction, p5Ref.current)
          p5InstanceRef.current = instance // Store in ref
          console.log('[CanvasComponent] P5 instance created.')

          // Initial resize after instance creation
          if (parentRef.current) {
            const { clientWidth, clientHeight } = parentRef.current
            if (clientWidth > 0 && clientHeight > 0) {
              instance.resizeCanvas(clientWidth, clientHeight)
              if (typeof instance.windowResized === 'function') {
                instance.windowResized()
              }
              setDimensions({ width: clientWidth, height: clientHeight }) // Store dimensions
            }
          }
        } catch (error) {
          console.error('Error creating P5 instance in CanvasComponent:', error)
          p5InstanceRef.current = null
        }
      } else {
        // Cleanup if sketchCanvas is removed or refs are missing
        if (p5InstanceRef.current) {
          console.log('[CanvasComponent] Removing P5 instance (no sketch/ref).')
          p5InstanceRef.current.remove()
          p5InstanceRef.current = null
        }
      }
    }

    initializeP5()

    // Cleanup function to remove the P5 instance
    return () => {
      isMounted = false
      if (p5InstanceRef.current) {
        console.log('[CanvasComponent] Removing P5 instance on cleanup.')
        p5InstanceRef.current.remove()
        p5InstanceRef.current = null
      }
    }
    // Depend on sketchCanvas and theme
  }, [sketchCanvas, currentTheme])

  // ResizeObserver logic
  useEffect(() => {
    const observer = new ResizeObserver(([entry]) => {
      const { contentRect } = entry
      const newWidth = contentRect?.width
      const newHeight = contentRect?.height
      if (p5InstanceRef.current && newWidth && newHeight) {
        p5InstanceRef.current.resizeCanvas(newWidth, newHeight)
        if (typeof p5InstanceRef.current.windowResized === 'function') {
          p5InstanceRef.current.windowResized()
        }
        setDimensions({ width: newWidth, height: newHeight }) // Update dimensions
      }
    })

    let parentElement: HTMLDivElement | null = null
    if (parentRef.current) {
      parentElement = parentRef.current
      observer.observe(parentElement)
    }

    return () => {
      if (parentElement) {
        observer.unobserve(parentElement)
      }
      observer.disconnect()
    }
  }, []) // No dependency on p5InstanceRef to avoid re-observing unnecessarily

  // Only render the container if a sketch is supposed to be there
  if (!sketchCanvas) {
    return null // Or a placeholder if needed
  }

  return (
    <Container ref={parentRef}>
      <Canvas ref={p5Ref} />
    </Container>
  )
}

export default CanvasComponent
""""""


File: src/components/Core/Canvas/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  max-height: 100%;
  max-height: 100%;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
`
export const Canvas = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  min-height: 100px;
`
""""""


File: src/components/Core/DiffEditor/index.tsx
""""""
import useWindow from 'src/hooks/useWindow'
import useContextTheme from 'src/hooks/useContextTheme'
import { useEffect, useRef } from 'react'
import { DiffEditor, Monaco } from '@monaco-editor/react'

type EditorProps = {
  currentExt: string
  currentContent: string
  currentNewContent: string
}

const DiffEditorComponent: React.FC<EditorProps> = ({
  currentExt,
  currentContent,
  currentNewContent
}) => {
  const LoadingEditor = () => {
    return <div />
  }

  const { selectedTheme } = useContextTheme()
  const { isMedium } = useWindow()

  const agnosticConfig = {
    quickSuggestions: false,
    model: null,
    readOnly: true
  }

  const hideLineNumberOptions = {
    enableSplitViewResizing: false,
    renderSideBySide: false,
    lineNumbers: 'off',
    glyphMargin: false,
    folding: false,
    lineDecorationsWidth: 0,
    lineNumbersMinChars: 0,
    ...agnosticConfig,
    wordWrap: 'on',
    fontSize: '12px',
    tabSize: 1,
    minimap: {
      enabled: false
    }
  }

  const showLineNumberOptions = {
    enableSplitViewResizing: true,
    renderSideBySide: true,
    lineNumbers: 'on',
    glyphMargin: true,
    wordWrap: 'on',
    folding: true,
    ...agnosticConfig,
    minimap: {
      enabled: true
    }
  }
  const editorRef = useRef({ revealLine: (n: number) => !n && console.log(n) })

  useEffect(() => {
    if (editorRef?.current?.revealLine) editorRef?.current?.revealLine(1)
  }, [])

  const handleEditorDidMount = (monaco: Monaco, editor: Monaco) => {
    monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
      noLib: true,
      allowNonTsExtensions: true
    })

    editorRef.current = editor

    monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
      noSemanticValidation: true,
      noSyntaxValidation: true,
      onlyVisible: true
    })

    monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
      comments: 'ignore'
    })
  }

  const options = isMedium
    ? { ...hideLineNumberOptions }
    : { ...showLineNumberOptions }

  return (
    <DiffEditor
      options={options}
      language={currentExt}
      original={currentContent}
      modified={currentNewContent}
      theme={selectedTheme}
      onMount={(editor, monaco) => handleEditorDidMount(monaco, editor)}
      loading={<LoadingEditor />}
    />
  )
}

export default DiffEditorComponent
""""""


File: src/components/Core/DragDrop/index.tsx
""""""
import { useState, useEffect } from 'react'
import { HighlightPosition, Container } from './styled'

interface DragDropComponentProps {
  onPosition?: (position: HighlightPosition, file: string) => void
  children: React.ReactNode
}

const DragDropComponent: React.FC<DragDropComponentProps> = ({
  onPosition,
  children
}) => {
  const [highlightPosition, setHighlightPosition] =
    useState<HighlightPosition>(null)
  const [isDragging, setIsDragging] = useState(false)
  const [draggedFile, setDraggedFile] = useState<string | null>(null)

  useEffect(() => {
    if (isDragging && draggedFile) {
      const handleDragEnd = () => {
        if (onPosition) {
          onPosition(highlightPosition, draggedFile)
        }
        setHighlightPosition(null)
        setIsDragging(false)
        setDraggedFile(null)
      }

      document.addEventListener('dragend', handleDragEnd)
      return () => {
        document.removeEventListener('dragend', handleDragEnd)
      }
    }
  }, [isDragging, onPosition, highlightPosition, draggedFile])

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    if (!isDragging) {
      setIsDragging(true)
    }
    updateHighlightPosition(e)
  }

  const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    updateHighlightPosition(e)
  }

  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
    if (!e.currentTarget.contains(e.relatedTarget as Node)) {
      setHighlightPosition(null)
    }
  }

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    const fileData = JSON.parse(e.dataTransfer.getData('file')) as string
    setDraggedFile(fileData)
  }

  const updateHighlightPosition = (e: React.DragEvent<HTMLDivElement>) => {
    const { clientX, clientY } = e
    const { left, right, top, bottom, width, height } =
      e.currentTarget.getBoundingClientRect()
    const thresholdX = width * 0.25
    const thresholdY = height * 0.25
    let newPosition: HighlightPosition

    if (clientX < left + thresholdX) {
      newPosition = 'left'
    } else if (clientX > right - thresholdX) {
      newPosition = 'right'
    } else if (clientY < top + thresholdY) {
      newPosition = 'top'
    } else if (clientY > bottom - thresholdY) {
      newPosition = 'bottom'
    } else {
      newPosition = 'center'
    }

    setHighlightPosition(newPosition)
  }

  return (
    <Container
      highlight={highlightPosition}
      onDragOver={handleDragOver}
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      {children}
    </Container>
  )
}

export default DragDropComponent
""""""


File: src/components/Core/DragDrop/styled.ts
""""""
import styled from 'styled-components'

export type HighlightPosition =
  | 'left'
  | 'right'
  | 'top'
  | 'bottom'
  | 'center'
  | null

export const Container = styled.div<{ highlight: HighlightPosition }>`
  width: 100%;
  height: 100%;
  border-radius: 8px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 24px;
  color: #888;
  transition: all 0.3s ease;

  &::after {
    content: '';
    position: absolute;
    background-color: rgba(0, 123, 255, 0.2);
    transition: all 0.3s ease;

    ${({ highlight }) => {
      switch (highlight) {
        case 'top':
          return `
            top: 0;
            left: 0%;
            right: 0%;
            height: 25%;
            border-bottom: 2px solid rgba(0, 123, 255, 0.8);
          `
        case 'bottom':
          return `
            bottom: 0;
            left: 0%;
            right: 0%;
            height: 25%;
            border-top: 2px solid rgba(0, 123, 255, 0.8);
          `
        case 'left':
          return `
            top: 0%;
            bottom: 0%;
            left: 0;
            width: 25%;
            border-right: 2px solid rgba(0, 123, 255, 0.8);
          `
        case 'right':
          return `
            top: 0%;
            bottom: 0%;
            right: 0;
            width: 25%;
            border-left: 2px solid rgba(0, 123, 255, 0.8);
          `
        case 'center':
          return `
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 123, 255, 0.5);
            border: 2px solid rgba(0, 123, 255, 0.8);
          `
        default:
          return `display: none;`
      }
    }}
  }

  &:hover {
    border-color: #888;
  }
`
""""""


File: src/components/Core/Editor/index.tsx
""""""
import useWindow from 'src/hooks/useWindow'
import useContextTheme from 'src/hooks/useContextTheme'
import MonacoEditor, { Monaco } from '@monaco-editor/react'

import { useRef } from 'react'

type EditorProps = {
  currentExt: string
  currentContent: string
  onChange: (value?: string | undefined) => void
}

const Editor: React.FC<EditorProps> = ({
  currentExt,
  currentContent,
  onChange
}) => {
  const LoadingEditor = () => {
    return <div></div>
  }

  const editorRef = useRef(null)

  const { selectedTheme } = useContextTheme()
  const { isMedium } = useWindow()

  const agnosticConfig = {
    quickSuggestions: false
  }

  const hideLineNumberOptions = {
    lineNumbers: 'off',
    glyphMargin: false,
    folding: false,
    lineDecorationsWidth: 0,
    lineNumbersMinChars: 0,
    ...agnosticConfig,
    wordWrap: 'on',
    fontSize: '12px',
    tabSize: 1,
    minimap: {
      enabled: false
    }
  }

  const showLineNumberOptions = {
    lineNumbers: 'on',
    glyphMargin: true,
    wordWrap: 'on',
    folding: true,
    ...agnosticConfig,
    minimap: {
      enabled: true
    }
  }

  const handleEditorDidMount = (monaco: Monaco, editor: Monaco) => {
    monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
      noLib: true,
      allowNonTsExtensions: true
    })

    editorRef.current = editor

    monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
      noSemanticValidation: true,
      noSyntaxValidation: true,
      onlyVisible: true
    })

    monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
      comments: 'ignore'
    })
  }

  const options = isMedium
    ? { ...hideLineNumberOptions }
    : { ...showLineNumberOptions }

  return (
    <MonacoEditor
      options={options}
      language={currentExt}
      value={currentContent}
      theme={selectedTheme}
      onMount={(editor, monaco) => handleEditorDidMount(monaco, editor)}
      loading={<LoadingEditor />}
      onChange={onChange}
      line={1}
    />
  )
}

export default Editor
""""""


File: src/components/Core/Engine/Body.ts
""""""
import Calculator from './Calculator'
import type P5 from 'p5' // Use type import
const calculator = new Calculator()

type Vector = {
  x: number
  y: number
}

export default class Body {
  coordinates: Vector
  velocity: Vector
  acceleration: Vector
  mass: number
  stroke?: number
  randomNum: number
  color: [number, number, number, number?]
  constructor(
    coordinates: Vector,
    velocity: Vector,
    acceleration: Vector,
    mass: number,
    color?: string
  ) {
    this.coordinates = coordinates
    this.velocity = velocity
    this.acceleration = acceleration
    this.mass = mass
    this.randomNum = calculator.randomInteger(50, 220)
    this.color = color
      ? calculator.transformHEXOnRGB(color)
      : [this.randomNum, this.randomNum, this.randomNum]
  }

  printProperties(): void {
    console.log('coordinates:', this.coordinates)
    console.log('velocity:', this.velocity)
    console.log('acceleration:', this.acceleration)
  }

  update(gravity: Vector): void {
    this.applyAcceleration(gravity)
  }

  applyAcceleration(acceleration = this.acceleration): void {
    this.acceleration = acceleration
    this.updateVelocity()
  }

  updateVelocity(acceleration = this.acceleration): void {
    this.velocity = calculator.sumVector(this.velocity, acceleration)
    this.UpdateCoordinates()
  }

  UpdateCoordinates(velocity = this.velocity): void {
    this.coordinates = calculator.sumVector(this.coordinates, velocity)
  }

  draw(p5: P5): void {
    p5.fill(p5.color(...this.color))
    p5.strokeWeight(0)
    p5.ellipse(
      this.coordinates.x,
      this.coordinates.y,
      this.mass * 10,
      this.mass * 10
    )
  }
}
""""""


File: src/components/Core/Engine/Calculator.ts
""""""
// Removed: import type P5 from 'p5'; // No longer needed here

type Vector = {
  x: number
  y: number
}

export default class Calculator {
  transformHEXOnRGB(string: string): [r: number, g: number, b: number] {
    const hex = string.replace('#', '')
    const bigint = parseInt(hex, 16)
    const r = (bigint >> 16) & 255 || 0
    const g = (bigint >> 8) & 255 || 0
    const b = bigint & 255 || 0
    return [r, g, b]
  }

  sumVector(vector1: Vector, vector2: Vector): Vector {
    const vector1Entries = Object.entries(vector1)
    const vector2Entries = Object.entries(vector2)

    const [vectorLargeDimensionEntries, vectorSmallerDimensionEntries] =
      vector1Entries.length <= vector2Entries.length
        ? [vector1Entries, vector2Entries]
        : [vector2Entries, vector1Entries]

    const sumOfEntries = vectorLargeDimensionEntries.map(
      ([keyFromLarger, valueFromLarger]) => {
        const currentMatch = vectorSmallerDimensionEntries.find(
          ([keyFromSmaller]) => keyFromSmaller === keyFromLarger
        )
        const currentMatchValue =
          currentMatch && currentMatch[1] ? currentMatch[1] : 0
        return [keyFromLarger, valueFromLarger + currentMatchValue]
      }
    )

    return Object.fromEntries(sumOfEntries)
  }

  divideVectorByNumber(vector1: Vector, number: number): Vector {
    const vectorEntries = Object.entries(vector1)
    const vectorDivided = vectorEntries.map(([key, value]) => [
      key,
      value / number
    ])
    return Object.fromEntries(vectorDivided)
  }

  randomInteger(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1) + min)
  }

  createRandomVector(vectorBluePrint: Array<[number, number]>): Vector {
    const [xTemplate, yTemplate] = vectorBluePrint
    return {
      x: this.randomInteger(...xTemplate),
      y: this.randomInteger(...yTemplate)
    }
  }
}
""""""


File: src/components/Core/Engine/README.md
""""""

This directory contains a very simple 2D physics engine used by some of the P5.js sketches (see [Sketches README](../Sketchs/README.md)).

## Components

-   **`Body.ts`**: Represents a physical body (like a particle or circle) with properties:
    -   `coordinates`: Position vector {x, y}.
    -   `velocity`: Velocity vector {x, y}.
    -   `acceleration`: Acceleration vector {x, y}.
    -   `mass`: Scalar mass.
    -   `color`: RGB(A) color array.
    -   Methods for updating position based on velocity and acceleration (`update`, `applyAcceleration`, `updateVelocity`, `UpdateCoordinates`) and drawing the body (`draw`).
-   **`Calculator.ts`**: Provides utility functions for vector math and other calculations needed by the engine and sketches:
    -   `transformHEXOnRGB`: Converts hex color strings to RGB arrays.
    -   `sumVector`: Adds two vectors.
    -   `divideVectorByNumber`: Divides a vector by a scalar.
    -   `randomInteger`: Generates a random integer within a range.
    -   `createRandomVector`: Creates a vector with random components based on provided ranges.

## Usage

Sketches typically import `Body` and `Calculator` to create and manage multiple `Body` instances, update their states in each frame, and draw them on the P5 canvas.

## Related READMEs

-   [Core Components README](../README.md)
-   [Sketches README](../Sketchs/README.md)
-   [Root README](../../../../README.md)
""""""


File: src/components/Core/FloatMenu/index.tsx
""""""
import { useState } from 'react'

import {
  Container,
  Content,
  Option,
  Background,
  TextComponent,
  OptionContainer
} from './styled'

type Option = {
  labels: string[]
  onClick: () => void
}

type FloatMenuProps = {
  options?: Option[]
}

const FloatMenu: React.FC<FloatMenuProps> = ({ options, children }) => {
  const [open, setOpen] = useState(false)

  return (
    <Container onClick={() => setOpen(!open)}>
      {children}
      {open && (
        <>
          <Background />
          <Content>
            {options?.map(({ labels, onClick }) => (
              <OptionContainer key={labels.join()} onClick={onClick}>
                <Option>
                  {labels.map(label => (
                    <TextComponent size={12} key={label}>
                      {label}
                    </TextComponent>
                  ))}
                </Option>
              </OptionContainer>
            ))}
          </Content>
        </>
      )}
    </Container>
  )
}

export default FloatMenu
""""""


File: src/components/Core/FloatMenu/styled.ts
""""""
import styled from 'styled-components'
import Text from 'src/components/Core/Text'

export const TextComponent = styled(Text)`
  padding: 0px 20px;
`

export const Container = styled.div`
  position: relative;
`

export const Background = styled.div`
  width: 100%;
  height: 100%;
  position: fixed;
  top: 0px;
  left: 0px;
  z-index: 999;
`
export const Content = styled.div`
  background: ${({ theme }) => theme.colors.menuBackground};
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
  position: absolute;
  bottom: 0;
  left: 100%;
  z-index: 999;
  border-radius: 2px;
`

export const OptionContainer = styled.div`
  padding: 0px 5px;
  :hover {
    background-color: ${({ theme }) => theme.colors.selectedBlue};
  }
  div {
    border-bottom: 1px solid ${({ theme }) => theme.colors.fileLine};
  }
  :last-child {
    div {
      border-bottom: none;
    }
  }
`

export const Option = styled.div`
  display: flex;
  cursor: pointer;
  justify-content: space-between;
  min-width: max-content;
  width: 100%;
  padding: 5px 0px;
`
""""""


File: src/components/Core/FloatingWindow/index.tsx
""""""
import { useState, useCallback, useEffect } from 'react'
import { DraggableWindow } from './styled'

interface FloatingWindowProps {
  zIndex?: number
  children: React.ReactNode
  x?: number
  y?: number
  width?: number
  height?: number
}

interface Position {
  x: number
  y: number
}

const AppBarHeight = 75 // Define the height of the AppBar

const FloatingWindow: React.FC<FloatingWindowProps> = ({
  zIndex = 999,
  children,
  x = 0,
  y = AppBarHeight, // Set initial y to AppBarHeight to start below the AppBar
  width = 200,
  height = 200
}) => {
  if (typeof window === 'undefined') return null
  const constrainPosition = useCallback(
    (x: number, y: number) => {
      const viewportWidth = window.innerWidth
      const viewportHeight = window.innerHeight
      const constrainedX = Math.min(Math.max(0, x), viewportWidth - width)
      const constrainedY = Math.min(
        Math.max(AppBarHeight, y),
        viewportHeight - height
      ) // Prevent y from being less than AppBarHeight
      return { x: constrainedX, y: constrainedY }
    },
    [width, height]
  )

  const [dragging, setDragging] = useState<boolean>(false)
  const [position, setPosition] = useState<Position>(() =>
    constrainPosition(x, y)
  )
  const [relPosition, setRelPosition] = useState<Position>({ x: 0, y: 0 })

  const onStart = useCallback(
    (clientX: number, clientY: number) => {
      setDragging(true)
      setRelPosition({
        x: clientX - position.x,
        y: clientY - position.y
      })
    },
    [position]
  )

  const onEnd = useCallback(() => {
    setDragging(false)
  }, [])

  const onMove = useCallback(
    (clientX: number, clientY: number) => {
      if (dragging) {
        const newX = clientX - relPosition.x
        const newY = clientY - relPosition.y
        const constrainedPosition = constrainPosition(newX, newY)
        setPosition(constrainedPosition)
      }
    },
    [dragging, relPosition, constrainPosition]
  )

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => onMove(e.clientX, e.clientY)
    const handleTouchMove = (e: TouchEvent) =>
      onMove(e.touches[0].clientX, e.touches[0].clientY)
    const handleResize = () => {
      const updatedPosition = constrainPosition(position.x, position.y)
      setPosition(updatedPosition)
    }

    window.addEventListener('resize', handleResize)
    if (dragging) {
      window.addEventListener('mousemove', handleMouseMove)
      window.addEventListener('touchmove', handleTouchMove, { passive: false })
      window.addEventListener('mouseup', onEnd)
      window.addEventListener('touchend', onEnd)
    } else {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('touchmove', handleTouchMove)
      window.removeEventListener('mouseup', onEnd)
      window.removeEventListener('touchend', onEnd)
    }

    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('touchmove', handleTouchMove)
      window.removeEventListener('mouseup', onEnd)
      window.removeEventListener('touchend', onEnd)
      window.removeEventListener('resize', handleResize)
    }
  }, [dragging, onMove, onEnd, constrainPosition, position])

  return (
    <DraggableWindow
      x={position.x}
      y={position.y}
      $zIndex={zIndex}
      width={width}
      height={height}
      onMouseDown={e => onStart(e.clientX, e.clientY)}
      onTouchStart={e => {
        e.preventDefault() // Prevents mobile scrolling when dragging
        onStart(e.touches[0].clientX, e.touches[0].clientY)
      }}
      onClick={e => e.stopPropagation()}
    >
      {children}
    </DraggableWindow>
  )
}

export default FloatingWindow
""""""


File: src/components/Core/FloatingWindow/styled.ts
""""""
import styled from 'styled-components'

export const DraggableWindow = styled.div.attrs<{
  x: number
  y: number
  $zIndex: number
  width: number
  height: number
}>(props => ({
  style: {
    left: `${props.x}px`,
    top: `${props.y}px`,
    zIndex: props.$zIndex,
    width: `${props.width}px`,
    height: `${props.height}px`
  }
}))<{ x: number; y: number; $zIndex: number; width: number; height: number }>`
  position: fixed;
  cursor: grab;
  display: flex;
  align-items: center;
  justify-content: center;
`
""""""


File: src/components/Core/GuideTour/Step/index.tsx
""""""
import Text from 'src/components/Core/Text'
import { Container, Header, Body } from './styled'

export type StepProps = { emoticon: string; title: string; content: string }

const Step: React.FC<StepProps> = ({ emoticon, title, content }) => {
  return (
    <Container>
      <Header>
        <Text as="h1">{emoticon}</Text>
        <Text as="h1">{title}</Text>
      </Header>
      <Body>
        <Text>{content}</Text>
      </Body>
    </Container>
  )
}

export default Step
""""""


File: src/components/Core/GuideTour/Step/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  max-width: 100%;
  height: 100%;
`

export const Body = styled.div`
  box-sizing: border-box;
  max-width: 100%;
  text-align: center;
`
export const Header = styled.div`
  display: grid;
  grid-template-columns: max-content 1fr;
  grid-gap: 10px;
  align-content: center;
  text-align: center;
  padding: 6px;
  padding-bottom: 16px;
  @media (max-width: ${({ theme }) => theme.breakpoints.xSmall}) {
    grid-template-columns: 1fr;
    grid-template-rows: max-content max-content;
  }
`
""""""


File: src/components/Core/GuideTour/index.tsx
""""""
import { useContextGuideTour } from 'src/hooks/useGuideTour'
import { TourComponent } from './styled'
import { useTheme } from 'styled-components'

const GuideTour: React.FC = () => {
  const { steps, setTour, isTourOpen } = useContextGuideTour()
  const theme = useTheme()

  return isTourOpen ? (
    <TourComponent
      steps={steps}
      className="guide"
      isOpen={isTourOpen}
      rounded={10}
      accentColor={theme.colors.accentColor}
      onRequestClose={() => setTour(false)}
    />
  ) : (
    <></>
  )
}

export default GuideTour
""""""


File: src/components/Core/GuideTour/styled.ts
""""""
import dynamic from 'next/dynamic'

import styled from 'styled-components'

const Tour = dynamic(() => import('reactour'), { ssr: false })

export const TourComponent = styled(Tour)`
  &&& {
    background: ${({ theme }) => theme.colors.editorBackground};
    color: ${({ theme }) => theme.colors.text};
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    transition: 1all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    box-sizing: border-box;
    max-width: min(80%, 600px);
    :hover {
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25),
        0 10px 10px rgba(0, 0, 0, 0.22);
    }
    @media (max-width: ${({ theme }) => theme.breakpoints.small}) {
      left: 10px;
      padding: 14px;
    }
  }
`

export const Container = styled.div``
""""""


File: src/components/Core/Icons/index.tsx
""""""
import Image from 'next/image'
import { Container } from './styled'
export type IconProps = {
  variant: string
  width: string
  height: string
}

const Icon: React.FC<IconProps> = ({
  variant,
  width = '50px',
  height = '50px'
}) => {
  const path = `/icons/${variant}.svg`
  return (
    <Container>
      <Image
        alt={variant}
        title={variant}
        src={path}
        width={width}
        height={height}
      />
    </Container>
  )
}

export default Icon
""""""


File: src/components/Core/Icons/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  cursor: pointer;
  width: min-content;
  display: flex;
  width: fit-content;
`
""""""


File: src/components/Core/InputText/index.tsx
""""""
import { Input } from './styled'

export type InputTextProps = {
  value?: string
  id?: string
  name?: string
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void
}

const InputText: React.FC<InputTextProps> = ({ value, onChange, id, name }) => {
  return (
    <Input value={value} id={id} name={name} onChange={onChange} type="text" />
  )
}

export default InputText
""""""


File: src/components/Core/InputText/styled.ts
""""""
import styled from 'styled-components'

export const Input = styled.input`
  background-color: transparent;
  border-width: 0px;
  border: none;
  outline: 0;
  color: ${({ theme }) => theme.colors.text};
  font: 400 16px sans-serif;
`
""""""


File: src/components/Core/Loading/index.tsx
""""""
import useContextLoading from 'src/hooks/useLoading'
import AnimationOverlay from 'src/components/Core/AnimationOverlay'

const Loading: React.FC = () => {
  const { loading, setLoading } = useContextLoading()

  return (
    <>
      {loading && (
        <AnimationOverlay
          sketchName="Bouncing" // Changed default from RandomWalker to Bouncing
          onClose={() => setLoading(false)}
        />
      )}
    </>
  )
}

export default Loading
""""""


File: src/components/Core/Loading/styled.ts
""""""
import styled from 'styled-components'

interface Props {
  isLoading: boolean
}

// This container might just be for positioning or a background if needed,
// as the actual animation is handled by the global AnimationHost.
// If Loading component becomes purely logical (triggering context), this might be removed.
export const Container = styled.div<Pick<Props, 'isLoading'>>`
  /* display: ${({ isLoading }) => (isLoading ? 'block' : 'none')}; */
  /* Remove positioning/sizing if AnimationHost handles it globally */
  /* Keep if you want a specific background behind the global animation */
`
""""""


File: src/components/Core/Modal/index.tsx
""""""
import { Container, Background } from './styled'

export type ModalProps = {
  open?: boolean
  setClose: () => void
}

const Modal: React.FC<ModalProps> = ({ children, open, setClose }) => {
  return (
    <Container open={open}>
      <Background onClick={() => setClose()}>{children}</Background>
    </Container>
  )
}

export default Modal
""""""


File: src/components/Core/Modal/styled.ts
""""""
import styled from 'styled-components'

interface PropsContainer {
  open?: boolean
}

export const Container = styled.div<PropsContainer>`
  display: ${({ open }) => (open ? 'flex' : 'none')};
  position: fixed;
  width: 100vw;
  height: 100vh;
`

export const Background = styled.div`
  position: relative;
  width: 100%;
  height: 100%;
`
""""""


File: src/components/Core/P5Preloader/index.tsx
""""""
import { useEffect } from 'react'

const P5Preloader: React.FC = () => {
  useEffect(() => {
    let isMounted = true
    console.log(
      '[P5Preloader] Component mounted. Attempting to preload P5.js...'
    )

    import('p5')
      .then(p5Module => {
        if (isMounted) {
          console.log(
            '[P5Preloader] P5.js module successfully preloaded:',
            p5Module ? 'OK' : 'Module Empty?'
          )
        }
      })
      .catch(error => {
        if (isMounted) {
          console.error('[P5Preloader] Error preloading P5.js:', error)
        }
      })

    return () => {
      isMounted = false
      console.log('[P5Preloader] Component unmounted.')
    }
  }, []) // Empty dependency array ensures this runs only once on mount

  // This component renders nothing visible
  return null
}

export default P5Preloader
""""""


File: src/components/Core/Printable/index.tsx
""""""
import Text from 'src/components/Core/Text'
import { Container, Img, Content } from './styled'
import { useContextFile } from 'src/hooks/useContextFile'
import styled from 'styled-components'

export type PrintableProps = {
  printRef: React.MutableRefObject<null>
}

const Printable: React.FC<PrintableProps> = ({ printRef }) => {
  const { files } = useContextFile()
  const resume = files.find(file => file.path.includes('-resume'))
  return (
    <Container ref={printRef}>
      <Content>
        <Img height="100px" width="100px" src="./profisionalProfile.png" />
        <Pre as="pre">{resume?.content}</Pre>
      </Content>
    </Container>
  )
}
export default Printable

const Pre = styled(Text)`
  color: black;
  white-space: pre-wrap;
  word-wrap: break-word;
  font-size: 14px;
  font-family: 'Roboto', sans-serif;
`
""""""


File: src/components/Core/Printable/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  display: none;
  @media print {
    display: block;
  }
`
export const Content = styled.div`
  @media print {
    max-width: 100%;
    display: block;
  }
`
export const Img = styled.img`
  @media print {
    float: left;
    display: block;
    border-radius: 50%;
`
""""""


File: src/components/Core/README.md
""""""
# src/components/Core/README.md

This directory houses the core, reusable React components of the application. These components are designed to be generic building blocks, independent of the specific features of the main "Home" view.

## Key Components

-   **`AnimationOverlay/`**: Renders a specific P5.js sketch dynamically in a modal-like overlay. It takes a `sketchName` prop, manually imports the corresponding sketch factory, dynamically loads P5.js, and manages the P5 instance lifecycle and cleanup. Triggered on demand (e.g., by Loading, Extensions panel, Debug button).
-   **`Canvas/`**: Renders P5.js sketches directly within the component tree (embedding). See the [Sketches README](./Sketchs/README.md) and [Engine README](./Engine/README.md).
-   **`DiffEditor/`**: A wrapper around Monaco Editor's diff view, used for showing changes in the Source Control panel.
-   **`DragDrop/`**: Provides a container that detects drag-and-drop events and highlights drop zones (top, bottom, left, right, center), used for arranging file views.
-   **`Editor/`**: A wrapper around the standard Monaco Editor, used for displaying and editing file content.
-   **`Engine/`**: A simple 2D physics engine used by some P5.js sketches. See the [Engine README](./Engine/README.md).
-   **`FloatMenu/`**: A component that displays a pop-up menu relative to its children (used for settings/profile icons in the NavBar).
-   **`FloatingWindow/`**: A draggable window component (currently unused but available).
-   **`GuideTour/`**: Components related to the `reactour` welcome guide steps.
-   **`Icons/`**: A simple component to render SVG icons.
-   **`InputText/`**: A basic styled text input component.
-   **`Loading/`**: Displays loading animations using the `AnimationOverlay` component (defaults to "Bouncing" sketch).
-   **`Modal/`**: A generic modal component with a background overlay.
-   **`P5Preloader/`**: A simple, invisible component that triggers the dynamic `import('p5')` on client-side mount to preload the library.
-   **`Printable/`**: A component containing the resume content formatted specifically for printing via `react-to-print`.
-   **`Shell/`**: A top-level component that applies the selected theme using `ThemeProvider`.
-   **`Sketchs/`**: Contains the P5.js animation sketches. See the [Sketches README](./Sketchs/README.md).
-   **`Splittable/`**: Uses `react-resizable-panels` to create splittable container views (horizontal or vertical).
-   **`Text/`**: A flexible text component based on `styled-components` for consistent typography.
-   **`TileFile/`**: Renders a single file/folder entry, typically used in file explorers or navigation tabs, showing icons and names.

## Related READMEs

-   [Components README](../README.md)
-   [Engine README](./Engine/README.md)
-   [Sketches README](./Sketchs/README.md)
-   [Root README](../../../README.md)
""""""


File: src/components/Core/Shell/index.tsx
""""""
import { ThemeProvider } from 'styled-components'
import { useContextTheme } from 'src/hooks/useContextTheme'
import theme from 'src/styles/theme'

const Shell: React.FC = ({ children }) => {
  const { selectedTheme } = useContextTheme()
  const currentTheme = theme[selectedTheme]
  return <ThemeProvider theme={currentTheme}>{children}</ThemeProvider>
}

export default Shell
""""""


File: src/components/Core/Sketchs/BoidsSimulation/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'
const GOOGLE_RED = '#DB4437'
const GOOGLE_YELLOW = '#F4B400'
const GOOGLE_GREEN = '#0F9D58'
const GOOGLE_COLORS = [GOOGLE_BLUE, GOOGLE_RED, GOOGLE_YELLOW, GOOGLE_GREEN]

class Boid {
  p5: P5
  position: P5.Vector
  velocity: P5.Vector
  acceleration: P5.Vector
  r: number // Size
  maxforce: number // Maximum steering force
  maxspeed: number // Maximum speed
  color: string
  width: number
  height: number

  constructor(p5: P5, x: number, y: number, width: number, height: number) {
    this.p5 = p5
    this.width = width
    this.height = height
    this.acceleration = p5.createVector(0, 0)
    this.velocity = p5.createVector(p5.random(-1, 1), p5.random(-1, 1))
    this.velocity.normalize()
    this.velocity.mult(p5.random(2, 4))

    this.position = p5.createVector(x, y)
    this.r = 3.0
    this.maxspeed = 3
    this.maxforce = 0.05
    this.color = p5.random(GOOGLE_COLORS)
  }

  flock(boids: Boid[]) {
    const sep = this.separate(boids)
    const ali = this.align(boids)
    const coh = this.cohesion(boids)
    sep.mult(1.5)
    ali.mult(1.0)
    coh.mult(1.0)
    this.applyForce(sep)
    this.applyForce(ali)
    this.applyForce(coh)
  }

  applyForce(force: P5.Vector) {
    this.acceleration.add(force)
  }

  update() {
    this.velocity.add(this.acceleration)
    this.velocity.limit(this.maxspeed)
    this.position.add(this.velocity)
    this.acceleration.mult(0)
  }

  separate(boids: Boid[]): P5.Vector {
    const desiredseparation = 25.0
    const steer = this.p5.createVector(0, 0)
    let count = 0
    for (const other of boids) {
      const d = this.position.dist(other.position)
      if (d > 0 && d < desiredseparation) {
        const diff = this.p5.constructor.Vector.sub(
          this.position,
          other.position
        )
        diff.normalize()
        diff.div(d)
        steer.add(diff)
        count++
      }
    }
    if (count > 0) {
      steer.div(count)
    }

    if (steer.mag() > 0) {
      steer.normalize()
      steer.mult(this.maxspeed)
      steer.sub(this.velocity)
      steer.limit(this.maxforce)
    }
    return steer
  }

  align(boids: Boid[]): P5.Vector {
    const neighbordist = 50
    const sum = this.p5.createVector(0, 0)
    let count = 0
    for (const other of boids) {
      const d = this.position.dist(other.position)
      if (d > 0 && d < neighbordist) {
        sum.add(other.velocity)
        count++
      }
    }
    if (count > 0) {
      sum.div(count)
      sum.normalize()
      sum.mult(this.maxspeed)
      const steer = this.p5.constructor.Vector.sub(sum, this.velocity)
      steer.limit(this.maxforce)
      return steer
    } else {
      return this.p5.createVector(0, 0)
    }
  }

  cohesion(boids: Boid[]): P5.Vector {
    const neighbordist = 50
    const sum = this.p5.createVector(0, 0)
    let count = 0
    for (const other of boids) {
      const d = this.position.dist(other.position)
      if (d > 0 && d < neighbordist) {
        sum.add(other.position)
        count++
      }
    }
    if (count > 0) {
      sum.div(count)
      return this.seek(sum)
    } else {
      return this.p5.createVector(0, 0)
    }
  }

  seek(target: P5.Vector): P5.Vector {
    const desired = this.p5.constructor.Vector.sub(target, this.position)
    desired.normalize()
    desired.mult(this.maxspeed)
    const steer = this.p5.constructor.Vector.sub(desired, this.velocity)
    steer.limit(this.maxforce)
    return steer
  }

  render() {
    const theta = this.velocity.heading() + this.p5.PI / 2
    this.p5.fill(this.color)
    this.p5.noStroke()
    this.p5.push()
    this.p5.translate(this.position.x, this.position.y)
    this.p5.rotate(theta)
    this.p5.beginShape()
    this.p5.vertex(0, -this.r * 2)
    this.p5.vertex(-this.r, this.r * 2)
    this.p5.vertex(this.r, this.r * 2)
    this.p5.endShape(this.p5.CLOSE)
    this.p5.pop()
  }

  borders() {
    if (this.position.x < -this.r) this.position.x = this.width + this.r
    if (this.position.y < -this.r) this.position.y = this.height + this.r
    if (this.position.x > this.width + this.r) this.position.x = -this.r
    if (this.position.y > this.height + this.r) this.position.y = -this.r
  }
}

const sketch =
  (
    _appTheme: Theme // Use _appTheme to avoid conflict with p5.theme
  ) =>
  (p5: P5): void => {
    const flock: Boid[] = []
    const numBoids = 150

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      flock.length = 0
      for (let i = 0; i < numBoids; i++) {
        flock.push(
          new Boid(
            p5,
            p5.random(p5.width),
            p5.random(p5.height),
            p5.width,
            p5.height
          )
        )
      }
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency
      for (const boid of flock) {
        boid.borders()
        boid.flock(flock)
        boid.update()
        boid.render()
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      p5.setup()
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/Bouncing/index.ts
""""""
import Calculator from 'src/components/Core/Engine/Calculator'
import Body from 'src/components/Core/Engine/Body'
import P5 from 'p5'
import theme from 'src/styles/theme'
type Theme = typeof theme['vs-dark']
const sketch =
  (_theme: Theme) =>
  (p5: P5): void => {
    const calculator = new Calculator()
    const bodies: Body[] = []

    const maxBodies = 100

    const forceField = { x: 0, y: 0 }

    const addNewRandomBody = () => {
      const newBody = new Body(
        calculator.createRandomVector([
          [0, p5.width],
          [0, p5.height]
        ]),
        calculator.createRandomVector([
          [-10, 10],
          [-10, 10]
        ]),
        calculator.createRandomVector([
          [-10, 10],
          [-10, 10]
        ]),
        calculator.randomInteger(10, 80) / 10
      )
      bodies.push(newBody)
    }

    const applyConstrains = (body: Body) => {
      const { x: xCoordinate, y: yCoordinate } = body.coordinates
      const { x: xVelocity, y: yVelocity } = body.velocity
      const bodySize = body.mass * 5

      if (xCoordinate > p5.width - bodySize) {
        body.coordinates.x = p5.width - bodySize
        if (xVelocity >= 0) {
          body.velocity.x = -body.velocity.x
        }
      }

      if (yCoordinate >= p5.height - bodySize) {
        body.coordinates.y = p5.height - bodySize
        if (yVelocity >= 0) {
          body.velocity.y = -body.velocity.y
        }
      }

      if (xCoordinate <= 0 + bodySize) {
        body.coordinates.x = 0 + bodySize
        if (xVelocity <= 0) {
          body.velocity.x = -body.velocity.x
        }
      }

      if (yCoordinate <= 0 + bodySize) {
        body.coordinates.y = 0 + bodySize
        if (yVelocity <= 0) {
          body.velocity.y = -body.velocity.y
        }
      }
    }

    p5.setup = (w = p5.windowWidth, h = p5.windowHeight) => {
      // Use windowWidth/Height
      p5.createCanvas(w, h)
      bodies.length = 0 // Clear bodies on setup
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency
      if (bodies.length < maxBodies) {
        addNewRandomBody()
      }

      bodies.forEach(body => {
        applyConstrains(body)
        body.UpdateCoordinates()
        body.update(forceField)
        body.draw(p5)
      })
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      p5.setup(p5.windowWidth, p5.windowHeight) // Re-run setup
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/DoublePendulum/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_RED = '#DB4437'
const GOOGLE_BLUE = '#4285F4'

const sketch =
  (
    appTheme: Theme // Renamed theme variable
  ) =>
  (p5: P5): void => {
    let r1 = 150 // Length of first arm
    let r2 = 150 // Length of second arm
    const m1 = 20 // Mass of first bob
    const m2 = 20 // Mass of second bob
    let a1 = p5.PI / 2 // Initial angle of first arm
    let a2 = p5.PI / 4 // Initial angle of second arm
    let a1_v = 0 // Initial velocity of first angle
    let a2_v = 0 // Initial velocity of second angle
    const g = 1 // Gravity

    let px2 = -1 // Previous x position of second bob
    let py2 = -1 // Previous y position of second bob
    let cx: number, cy: number // Center coordinates

    let buffer: P5.Graphics // Graphics buffer for drawing the trace

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      p5.pixelDensity(1)
      cx = p5.width / 2
      cy = p5.height / 3
      buffer = p5.createGraphics(p5.width, p5.height)
      buffer.background(appTheme.colors.editorBackground + '00') // Make buffer background transparent initially
      buffer.translate(cx, cy)
      buffer.stroke(GOOGLE_RED)
      buffer.strokeWeight(1)

      const minDim = Math.min(p5.width, p5.height)
      r1 = minDim * 0.25
      r2 = minDim * 0.25
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency on main canvas
      // Fade the buffer slightly each frame for a trailing effect
      buffer.background(appTheme.colors.editorBackground + '05') // Very transparent background to fade old lines

      // --- Physics Calculation ---
      const num1 = -g * (2 * m1 + m2) * p5.sin(a1)
      const num2 = -m2 * g * p5.sin(a1 - 2 * a2)
      const num3 = -2 * p5.sin(a1 - a2) * m2
      const num4 = a2_v * a2_v * r2 + a1_v * a1_v * r1 * p5.cos(a1 - a2)
      const den = r1 * (2 * m1 + m2 - m2 * p5.cos(2 * a1 - 2 * a2))
      const a1_a = (num1 + num2 + num3 * num4) / den

      const num5 = 2 * p5.sin(a1 - a2)
      const num6 = a1_v * a1_v * r1 * (m1 + m2)
      const num7 = g * (m1 + m2) * p5.cos(a1)
      const num8 = a2_v * a2_v * r2 * m2 * p5.cos(a1 - a2)
      const den2 = r2 * (2 * m1 + m2 - m2 * p5.cos(2 * a1 - 2 * a2))
      const a2_a = (num5 * (num6 + num7 + num8)) / den2

      a1_v += a1_a * 0.1
      a2_v += a2_a * 0.1
      a1 += a1_v * 0.1
      a2 += a2_v * 0.1
      // --- End Physics ---

      const x1 = r1 * p5.sin(a1)
      const y1 = r1 * p5.cos(a1)
      const x2 = x1 + r2 * p5.sin(a2)
      const y2 = y1 + r2 * p5.cos(a2)

      // Draw trace onto the buffer
      if (px2 !== -1) {
        buffer.stroke(GOOGLE_RED) // Ensure stroke is set before drawing line
        buffer.line(px2, py2, x2, y2)
      }
      px2 = x2
      py2 = y2

      // Draw buffer onto the main canvas
      p5.imageMode(p5.CORNER)
      p5.image(buffer, 0, 0, p5.width, p5.height)

      // Draw pendulum on main canvas (over the buffer)
      p5.push()
      p5.translate(cx, cy)
      p5.stroke(appTheme.colors.text)
      p5.strokeWeight(2)
      p5.line(0, 0, x1, y1)
      p5.fill(GOOGLE_BLUE)
      p5.ellipse(x1, y1, m1, m1)

      p5.line(x1, y1, x2, y2)
      p5.fill(GOOGLE_BLUE)
      p5.ellipse(x2, y2, m2, m2)
      p5.pop()
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      cx = p5.width / 2
      cy = p5.height / 3
      // Recreate and clear buffer
      buffer.resizeCanvas(p5.width, p5.height)
      buffer.background(appTheme.colors.editorBackground + '00') // Transparent background
      buffer.translate(cx, cy)
      buffer.stroke(GOOGLE_RED)
      buffer.strokeWeight(1)
      px2 = -1
      py2 = -1

      const minDim = Math.min(p5.width, p5.height)
      r1 = minDim * 0.25
      r2 = minDim * 0.25
      // Reset angles/velocities on resize? Optional, but good for consistency
      a1 = p5.PI / 2
      a2 = p5.PI / 4
      a1_v = 0
      a2_v = 0
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/FourierDrawing/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'

interface Complex {
  re: number
  im: number
}

interface FourierTerm {
  freq: number
  amp: number
  phase: number
}

function dft(p5: P5, x: Complex[]): FourierTerm[] {
  const X: FourierTerm[] = []
  const N = x.length
  for (let k = 0; k < N; k++) {
    let sumRe = 0
    let sumIm = 0
    for (let n = 0; n < N; n++) {
      const phi = (p5.TWO_PI * k * n) / N
      sumRe += x[n].re * p5.cos(phi) + x[n].im * p5.sin(phi)
      sumIm += -x[n].re * p5.sin(phi) + x[n].im * p5.cos(phi)
    }
    sumRe = sumRe / N
    sumIm = sumIm / N

    const freq = k
    const amp = p5.sqrt(sumRe * sumRe + sumIm * sumIm)
    const phase = p5.atan2(sumIm, sumRe)
    X[k] = { freq, amp, phase }
  }
  return X
}

const sketch =
  (appTheme: Theme) =>
  (p5: P5): void => {
    let time = 0
    let path: P5.Vector[] = []
    let drawing: Complex[] = []
    let fourierX: FourierTerm[] = []
    let state: 'USER_DRAWING' | 'FOURIER_DRAWING' = 'USER_DRAWING'
    let drawingComplete = false

    function loadSquare() {
      drawing = []
      const size = 100
      const steps = 50
      for (let i = 0; i < steps; i++)
        drawing.push({ re: -size + (size * 2 * i) / steps, im: -size })
      for (let i = 0; i < steps; i++)
        drawing.push({ re: size, im: -size + (size * 2 * i) / steps })
      for (let i = 0; i < steps; i++)
        drawing.push({ re: size - (size * 2 * i) / steps, im: size })
      for (let i = 0; i < steps; i++)
        drawing.push({ re: -size, im: size - (size * 2 * i) / steps })
      drawingComplete = true
      startFourier()
    }

    function startFourier() {
      if (drawing.length === 0) return
      state = 'FOURIER_DRAWING'
      fourierX = dft(p5, drawing)
      fourierX.sort((a, b) => b.amp - a.amp)
      time = 0
      path = []
    }

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      loadSquare()
    }

    function epicycles(
      x: number,
      y: number,
      rotation: number,
      fourier: FourierTerm[]
    ): P5.Vector {
      const center = p5.createVector(x, y)
      for (let i = 0; i < fourier.length; i++) {
        const prevx = x
        const prevy = y
        const freq = fourier[i].freq
        const radius = fourier[i].amp
        const phase = fourier[i].phase
        x += radius * p5.cos(freq * time + phase + rotation)
        y += radius * p5.sin(freq * time + phase + rotation)

        p5.stroke(appTheme.colors.text + '50')
        p5.noFill()
        p5.ellipse(prevx, prevy, radius * 2)
        p5.stroke(appTheme.colors.text + '90')
        p5.line(prevx, prevy, x, y)
      }
      return p5.createVector(x, y)
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency

      if (state === 'USER_DRAWING') {
        p5.stroke(appTheme.colors.text)
        p5.noFill()
        p5.beginShape()
        for (const v of drawing) {
          p5.vertex(v.re + p5.width / 2, v.im + p5.height / 2)
        }
        p5.endShape()
      } else if (state === 'FOURIER_DRAWING') {
        const v = epicycles(p5.width / 2, p5.height / 2, 0, fourierX)
        path.unshift(v)

        p5.beginShape()
        p5.noFill()
        p5.strokeWeight(2)
        p5.stroke(GOOGLE_BLUE)
        for (let i = 0; i < path.length; i++) {
          p5.vertex(path[i].x, path[i].y)
        }
        p5.endShape()

        const dt = p5.TWO_PI / fourierX.length
        time += dt

        if (time > p5.TWO_PI) {
          time = 0
          path = []
        }

        if (path.length > 500) {
          path.pop()
        }
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      loadSquare()
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/GameOfLife/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'
const GOOGLE_RED = '#DB4437'
const GOOGLE_YELLOW = '#F4B400'
const GOOGLE_GREEN = '#0F9D58'
const GOOGLE_COLORS = [GOOGLE_BLUE, GOOGLE_RED, GOOGLE_YELLOW, GOOGLE_GREEN]

const sketch =
  (appTheme: Theme) =>
  (p5: P5): void => {
    let w: number // Width of cell
    let columns: number
    let rows: number
    let board: number[][]
    let next: number[][]
    let generation = 0
    const cellColorMap: { [key: number]: string } = {}

    function initBoard() {
      board = new Array(columns)
      for (let i = 0; i < columns; i++) {
        board[i] = new Array(rows)
      }
      next = new Array(columns)
      for (let i = 0; i < columns; i++) {
        next[i] = new Array(rows)
      }
      for (let i = 0; i < columns; i++) {
        for (let j = 0; j < rows; j++) {
          if (i === 0 || j === 0 || i === columns - 1 || j === rows - 1) {
            board[i][j] = 0
          } else {
            board[i][j] = p5.floor(p5.random(2))
          }
          next[i][j] = 0
        }
      }
      generation = 0
      cellColorMap[0] = p5.random(GOOGLE_COLORS)
    }

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      w = 10
      columns = p5.floor(p5.width / w)
      rows = p5.floor(p5.height / w)
      initBoard()
      p5.frameRate(10)
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency
      generate()
      for (let i = 0; i < columns; i++) {
        for (let j = 0; j < rows; j++) {
          if (board[i][j] === 1) {
            const colorIndex = generation % GOOGLE_COLORS.length
            p5.fill(GOOGLE_COLORS[colorIndex])
          } else {
            p5.noFill() // Make dead cells transparent
          }
          p5.stroke(appTheme.colors.sideHighlight + '30')
          p5.rect(i * w, j * w, w - 1, w - 1)
        }
      }
    }

    function generate() {
      for (let x = 1; x < columns - 1; x++) {
        for (let y = 1; y < rows - 1; y++) {
          let neighbors = 0
          for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
              neighbors += board[x + i][y + j]
            }
          }
          neighbors -= board[x][y]

          if (board[x][y] === 1 && neighbors < 2) {
            next[x][y] = 0
          } else if (board[x][y] === 1 && neighbors > 3) {
            next[x][y] = 0
          } else if (board[x][y] === 0 && neighbors === 3) {
            next[x][y] = 1
          } else {
            next[x][y] = board[x][y]
          }
        }
      }

      const temp = board
      board = next
      next = temp
      generation++
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      columns = p5.floor(p5.width / w)
      rows = p5.floor(p5.height / w)
      initBoard()
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/GoogleFlowField/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'
const GOOGLE_RED = '#DB4437'
const GOOGLE_YELLOW = '#F4B400'
const GOOGLE_GREEN = '#0F9D58'
const GOOGLE_COLORS = [GOOGLE_BLUE, GOOGLE_RED, GOOGLE_YELLOW, GOOGLE_GREEN]

let rows: number // Keep rows in module scope

class Particle {
  p5: P5
  pos: P5.Vector
  vel: P5.Vector
  acc: P5.Vector
  maxSpeed: number
  prevPos: P5.Vector
  color: string
  width: number
  height: number

  constructor(p5: P5, width: number, height: number) {
    this.p5 = p5
    this.width = width
    this.height = height
    this.pos = p5.createVector(p5.random(width), p5.random(height))
    this.vel = p5.createVector(0, 0)
    this.acc = p5.createVector(0, 0)
    this.maxSpeed = 2
    this.prevPos = this.pos.copy()
    this.color = p5.random(GOOGLE_COLORS) + 'CC' // Slightly less transparent
  }

  update() {
    this.vel.add(this.acc)
    this.vel.limit(this.maxSpeed)
    this.pos.add(this.vel)
    this.acc.mult(0)
  }

  follow(vectors: P5.Vector[][], scl: number, cols: number) {
    const x = this.p5.floor(this.pos.x / scl)
    const y = this.p5.floor(this.pos.y / scl)
    if (
      x >= 0 &&
      x < cols &&
      y >= 0 &&
      y < rows &&
      vectors[y] &&
      vectors[y][x]
    ) {
      const force = vectors[y][x]
      this.applyForce(force)
    }
  }

  applyForce(force: P5.Vector) {
    this.acc.add(force)
  }

  show() {
    this.p5.stroke(this.color)
    this.p5.strokeWeight(1)
    this.p5.line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y)
    this.updatePrev()
  }

  updatePrev() {
    this.prevPos.x = this.pos.x
    this.prevPos.y = this.pos.y
  }

  edges() {
    if (this.pos.x > this.width) {
      this.pos.x = 0
      this.updatePrev()
    }
    if (this.pos.x < 0) {
      this.pos.x = this.width
      this.updatePrev()
    }
    if (this.pos.y > this.height) {
      this.pos.y = 0
      this.updatePrev()
    }
    if (this.pos.y < 0) {
      this.pos.y = this.height
      this.updatePrev()
    }
  }
}

const sketch =
  (_appTheme: Theme) =>
  (p5: P5): void => {
    const inc = 0.1
    const scl = 10
    let cols: number
    let zoff = 0
    const particles: Particle[] = []
    const numParticles = 500
    let flowfield: P5.Vector[][] = []

    function calculateFlowField() {
      flowfield = new Array(rows)
      let yoff = 0
      for (let y = 0; y < rows; y++) {
        flowfield[y] = new Array(cols)
        let xoff = 0
        for (let x = 0; x < cols; x++) {
          const angle = p5.noise(xoff, yoff, zoff) * p5.TWO_PI * 4
          const v = p5.constructor.Vector.fromAngle(angle)
          v.setMag(0.5)
          flowfield[y][x] = v
          xoff += inc
        }
        yoff += inc
      }
      zoff += 0.005
    }

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      cols = p5.floor(p5.width / scl)
      rows = p5.floor(p5.height / scl)

      calculateFlowField()

      particles.length = 0
      for (let i = 0; i < numParticles; i++) {
        particles[i] = new Particle(p5, p5.width, p5.height)
      }
      // No initial background needed with clear()
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency

      calculateFlowField()

      for (let i = 0; i < particles.length; i++) {
        particles[i].follow(flowfield, scl, cols)
        particles[i].update()
        particles[i].edges()
        particles[i].show()
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      p5.setup()
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/HexagonCollision/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'
const GOOGLE_RED = '#DB4437'
const GOOGLE_YELLOW = '#F4B400'
const GOOGLE_GREEN = '#0F9D58'
const GOOGLE_COLORS = [GOOGLE_BLUE, GOOGLE_RED, GOOGLE_YELLOW, GOOGLE_GREEN]

class Particle {
  p5: P5
  pos: P5.Vector
  vel: P5.Vector
  acc: P5.Vector
  mass: number
  radius: number
  color: string
  isTriangle: boolean
  angle: number
  angularVel: number

  constructor(
    p5: P5,
    x: number,
    y: number,
    isTriangle = false,
    color?: string
  ) {
    this.p5 = p5
    this.pos = p5.createVector(x, y)
    this.vel = p5.createVector(p5.random(-1, 1), p5.random(-1, 1))
    this.vel.normalize()
    this.vel.mult(p5.random(1, 3))

    this.acc = p5.createVector(0, 0)
    this.mass = isTriangle ? 5 : 20
    this.radius = isTriangle ? 10 : 30
    this.color = color || p5.random(GOOGLE_COLORS)
    this.isTriangle = isTriangle
    this.angle = p5.random(p5.TWO_PI)
    this.angularVel = p5.random(-0.05, 0.05)
  }

  applyForce(force: P5.Vector) {
    const f = this.p5.constructor.Vector.div(force, this.mass)
    this.acc.add(f)
  }

  update() {
    this.vel.add(this.acc)
    this.pos.add(this.vel)
    this.acc.mult(0)
    this.angle += this.angularVel
    this.edges()
  }

  collide(other: Particle) {
    const distanceVect = this.p5.constructor.Vector.sub(other.pos, this.pos)
    const distanceMag = distanceVect.mag()
    const minDistance = this.radius + other.radius

    if (distanceMag < minDistance) {
      const distanceCorrection = (minDistance - distanceMag) / 2.0
      const d = distanceVect.copy()
      const correctionVector = d.normalize().mult(distanceCorrection)
      other.pos.add(correctionVector)
      this.pos.sub(correctionVector)

      const theta = distanceVect.heading()
      const sine = this.p5.sin(theta)
      const cosine = this.p5.cos(theta)

      const bTemp = [this.p5.createVector(), this.p5.createVector()]

      bTemp[1].x = cosine * other.vel.x + sine * other.vel.y
      bTemp[1].y = cosine * other.vel.y - sine * other.vel.x
      bTemp[0].x = cosine * this.vel.x + sine * this.vel.y
      bTemp[0].y = cosine * this.vel.y - sine * this.vel.x

      const vTemp = [this.p5.createVector(), this.p5.createVector()]

      vTemp[0].x =
        ((this.mass - other.mass) * bTemp[0].x + 2 * other.mass * bTemp[1].x) /
        (this.mass + other.mass)
      vTemp[0].y = bTemp[0].y

      vTemp[1].x =
        ((other.mass - this.mass) * bTemp[1].x + 2 * this.mass * bTemp[0].x) /
        (this.mass + other.mass)
      vTemp[1].y = bTemp[1].y

      bTemp[0].x = cosine * vTemp[0].x - sine * vTemp[0].y
      bTemp[0].y = cosine * vTemp[0].y + sine * vTemp[0].x
      bTemp[1].x = cosine * vTemp[1].x - sine * vTemp[1].y
      bTemp[1].y = cosine * vTemp[1].y + sine * vTemp[1].x

      this.vel.x = bTemp[0].x
      this.vel.y = bTemp[0].y
      other.vel.x = bTemp[1].x
      other.vel.y = bTemp[1].y
    }
  }

  display() {
    this.p5.push()
    this.p5.translate(this.pos.x, this.pos.y)
    this.p5.rotate(this.angle)
    this.p5.noStroke()
    this.p5.fill(this.color)

    if (this.isTriangle) {
      this.p5.triangle(
        0,
        -this.radius,
        -this.radius * 0.866,
        this.radius * 0.5,
        this.radius * 0.866,
        this.radius * 0.5
      )
    } else {
      const angle = this.p5.TWO_PI / 6
      this.p5.beginShape()
      for (let a = 0; a < this.p5.TWO_PI - angle * 0.5; a += angle) {
        const sx = this.p5.cos(a) * this.radius
        const sy = this.p5.sin(a) * this.radius
        this.p5.vertex(sx, sy)
      }
      this.p5.endShape(this.p5.CLOSE)
    }
    this.p5.pop()
  }

  edges() {
    if (this.pos.x > this.p5.width + this.radius) {
      this.pos.x = -this.radius
    } else if (this.pos.x < -this.radius) {
      this.pos.x = this.p5.width + this.radius
    }
    if (this.pos.y > this.p5.height + this.radius) {
      this.pos.y = -this.radius
    } else if (this.pos.y < -this.radius) {
      this.pos.y = this.p5.height + this.radius
    }
  }
}

const sketch =
  (_theme: Theme) =>
  (p5: P5): void => {
    const particles: Particle[] = []
    const numHexagons = 5
    const releaseInterval = 60

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      particles.length = 0
      for (let i = 0; i < numHexagons; i++) {
        particles.push(
          new Particle(
            p5,
            p5.random(p5.width),
            p5.random(p5.height),
            false,
            p5.random(GOOGLE_COLORS)
          )
        )
      }
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency

      if (p5.frameCount % releaseInterval === 0) {
        particles.forEach(p => {
          if (!p.isTriangle) {
            const releaseAngle = p.angle + p5.PI
            const releasePos = p5
              .createVector(p5.cos(releaseAngle), p5.sin(releaseAngle))
              .mult(p.radius)
              .add(p.pos)
            const newTriangle = new Particle(
              p5,
              releasePos.x,
              releasePos.y,
              true,
              p.color
            )
            newTriangle.vel = p5.constructor.Vector.sub(releasePos, p.pos)
              .normalize()
              .mult(4)
            particles.push(newTriangle)
          }
        })
      }

      while (particles.length > 150) {
        const oldestTriangleIndex = particles.findIndex(p => p.isTriangle)
        if (oldestTriangleIndex !== -1) {
          particles.splice(oldestTriangleIndex, 1)
        } else {
          break
        }
      }

      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          particles[i].collide(particles[j])
        }
        particles[i].update()
        particles[i].display()
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      p5.setup()
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/Hypercube/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'

const sketch =
  (
    appTheme: Theme // Renamed theme variable
  ) =>
  (p5: P5): void => {
    let angle = 0
    const points: P5.Vector[] = []
    let projected3d: P5.Vector[] = []

    function rotateXY(v: P5.Vector, angle: number): P5.Vector {
      const r = p5.createVector()
      r.x = p5.cos(angle) * v.x - p5.sin(angle) * v.y
      r.y = p5.sin(angle) * v.x + p5.cos(angle) * v.y
      r.z = v.z
      // @ts-expect-error Adding w property dynamically
      r.w = v.w
      return r
    }

    function rotateZW(v: P5.Vector, angle: number): P5.Vector {
      const r = p5.createVector()
      // @ts-expect-error Accessing w property
      const z = v.z
      // @ts-expect-error Accessing w property
      const w = v.w
      r.x = v.x
      r.y = v.y
      r.z = p5.cos(angle) * z - p5.sin(angle) * w
      // @ts-expect-error Adding w property dynamically
      r.w = p5.sin(angle) * z + p5.cos(angle) * w
      return r
    }
    function rotateXW(v: P5.Vector, angle: number): P5.Vector {
      const r = p5.createVector()
      const x = v.x
      // @ts-expect-error Accessing w property
      const w = v.w
      r.x = p5.cos(angle) * x - p5.sin(angle) * w
      r.y = v.y
      r.z = v.z
      // @ts-expect-error Adding w property dynamically
      r.w = p5.sin(angle) * x + p5.cos(angle) * w
      return r
    }

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight, p5.WEBGL)
      points.length = 0 // Clear points on setup
      for (let i = 0; i < 16; i++) {
        const x = i & 1 ? 1 : -1
        const y = i & 2 ? 1 : -1
        const z = i & 4 ? 1 : -1
        const w = i & 8 ? 1 : -1
        const vec = p5.createVector(x, y, z)
        // @ts-expect-error Adding w property dynamically
        vec.w = w
        points[i] = vec
      }
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency in WEBGL
      p5.orbitControl() // Allow user interaction
      // p5.rotateX(-p5.PI / 6) // Remove fixed rotation if using orbitControl
      // p5.rotateY(p5.PI / 4)

      projected3d = []

      for (let i = 0; i < points.length; i++) {
        let v = points[i]

        v = rotateXY(v, angle * 0.5)
        v = rotateZW(v, angle)
        v = rotateXW(v, angle * 1.5)

        // @ts-expect-error Accessing w property
        const w = v.w
        const distance = 2
        const perspectiveFactor = 1 / (distance - w)

        const projected = p5.createVector(
          v.x * perspectiveFactor,
          v.y * perspectiveFactor,
          v.z * perspectiveFactor
        )
        projected3d[i] = projected.mult(100)
      }

      p5.stroke(appTheme.colors.text)
      p5.strokeWeight(8)
      p5.noFill()
      for (let i = 0; i < projected3d.length; i++) {
        p5.point(projected3d[i].x, projected3d[i].y, projected3d[i].z)
      }

      p5.stroke(GOOGLE_BLUE)
      p5.strokeWeight(1)
      for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
          const diff = i ^ j
          if ((diff & (diff - 1)) === 0) {
            p5.line(
              projected3d[i].x,
              projected3d[i].y,
              projected3d[i].z,
              projected3d[j].x,
              projected3d[j].y,
              projected3d[j].z
            )
          }
        }
      }

      angle += 0.01
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      // No need to call setup usually for WEBGL resize unless camera perspective needs reset
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/LinearConservation/index.ts
""""""
import Calculator from 'src/components/Core/Engine/Calculator'
import Body from 'src/components/Core/Engine/Body'
import P5 from 'p5'
import theme from 'src/styles/theme'
type Theme = typeof theme['vs-dark']
const sketch =
  (_theme: Theme) =>
  (p5: P5): void => {
    const calculator = new Calculator()
    const bodies: Body[] = []

    const maxBodies = 1

    const forceField = { x: 0, y: 1 }

    const addNewRandomBody = () => {
      // Start body off-screen top-right for a better fall effect
      const newBody = new Body(
        { x: p5.width - 20, y: -50 }, // Start above canvas
        { x: p5.random(-5, -1), y: 0 }, // Initial horizontal velocity
        { x: 0, y: 0 }, // Initial acceleration
        calculator.randomInteger(10, 80) / 10
      )
      bodies.push(newBody)
    }

    const applyConstrains = (body: Body) => {
      const { x: xCoordinate, y: yCoordinate } = body.coordinates
      const { x: xVelocity, y: yVelocity } = body.velocity
      const bodySize = body.mass * 5

      // Right wall
      if (xCoordinate > p5.width - bodySize) {
        body.coordinates.x = p5.width - bodySize
        if (xVelocity > 0) {
          // Check direction
          body.velocity.x *= -0.9 // Bounce with slight energy loss
        }
      }

      // Floor
      if (yCoordinate >= p5.height - bodySize) {
        body.coordinates.y = p5.height - bodySize
        if (yVelocity > 0) {
          // Check direction
          // Dampen vertical velocity significantly on bounce
          body.velocity.y *= -0.6
          // Apply friction to horizontal velocity
          body.velocity.x *= 0.95
        }
        // Prevent sinking below floor
        if (Math.abs(body.velocity.y) < 0.1) {
          body.velocity.y = 0
        }
      }

      // Left wall
      if (xCoordinate <= 0 + bodySize) {
        body.coordinates.x = 0 + bodySize
        if (xVelocity < 0) {
          // Check direction
          body.velocity.x *= -0.9 // Bounce with slight energy loss
        }
      }

      // Ceiling (optional, less common for gravity simulation)
      if (yCoordinate <= 0 + bodySize) {
        body.coordinates.y = 0 + bodySize
        if (yVelocity < 0) {
          // Check direction
          body.velocity.y *= -0.9 // Bounce with slight energy loss
        }
      }
    }

    p5.setup = (w = p5.windowWidth, h = p5.windowHeight) => {
      // Use windowWidth/Height
      p5.createCanvas(w, h)
      bodies.length = 0 // Clear bodies on setup
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency
      if (bodies.length < maxBodies) {
        addNewRandomBody()
      }

      bodies.forEach(body => {
        // Only apply gravity if not resting on the floor
        if (
          body.coordinates.y < p5.height - body.mass * 5 ||
          Math.abs(body.velocity.y) > 0.1
        ) {
          body.update(forceField) // Apply gravity
        } else {
          body.update({ x: 0, y: 0 }) // No gravity if resting
        }
        applyConstrains(body)
        body.UpdateCoordinates() // Update position based on velocity
        body.draw(p5)
      })
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      p5.setup(p5.windowWidth, p5.windowHeight) // Re-run setup
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/Metaballs/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'
const GOOGLE_RED = '#DB4437'
const GOOGLE_YELLOW = '#F4B400'
const GOOGLE_GREEN = '#0F9D58'
const GOOGLE_COLORS = [GOOGLE_BLUE, GOOGLE_RED, GOOGLE_YELLOW, GOOGLE_GREEN]

class Ball {
  p5: P5
  pos: P5.Vector
  vel: P5.Vector
  r: number // Radius
  color: string
  width: number
  height: number

  constructor(p5: P5, width: number, height: number) {
    this.p5 = p5
    this.width = width
    this.height = height
    this.pos = p5.createVector(p5.random(width), p5.random(height))
    this.vel = p5.createVector(p5.random(-1, 1), p5.random(-1, 1))
    this.vel.normalize()
    this.vel.mult(p5.random(0.5, 1.5))

    this.r = p5.random(30, 60)
    this.color = p5.random(GOOGLE_COLORS)
  }

  update() {
    this.pos.add(this.vel)
    if (this.pos.x < this.r || this.pos.x > this.width - this.r) {
      this.vel.x *= -1
    }
    if (this.pos.y < this.r || this.pos.y > this.height - this.r) {
      this.vel.y *= -1
    }
  }
}

const sketch =
  (_appTheme: Theme) =>
  (p5: P5): void => {
    const balls: Ball[] = []
    const numBalls = 10
    let res = 5

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      p5.colorMode(p5.RGB, 255)
      balls.length = 0
      for (let i = 0; i < numBalls; i++) {
        balls.push(new Ball(p5, p5.width, p5.height))
      }
      res = p5.max(5, p5.floor(p5.min(p5.width, p5.height) / 100))
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency
      p5.loadPixels()

      for (let y = 0; y < p5.height; y += res) {
        for (let x = 0; x < p5.width; x += res) {
          let sum = 0
          for (let i = 0; i < balls.length; i++) {
            const ball = balls[i]
            const d = p5.dist(x, y, ball.pos.x, ball.pos.y)
            sum += (60 * ball.r) / d
          }

          let dominantColor = p5.color(0, 0, 0, 0) // Default to transparent
          let maxInfluence = 0
          if (sum > 80) {
            dominantColor = p5.color(GOOGLE_BLUE)
            for (let i = 0; i < balls.length; i++) {
              const ball = balls[i]
              const d = p5.dist(x, y, ball.pos.x, ball.pos.y)
              const influence = (60 * ball.r) / d
              if (influence > maxInfluence) {
                maxInfluence = influence
                dominantColor = p5.color(ball.color)
              }
            }
          }

          p5.fill(dominantColor)
          p5.noStroke()
          p5.rect(x, y, res, res)
        }
      }
      // No need to updatePixels if not directly manipulating pixel array

      for (let i = 0; i < balls.length; i++) {
        balls[i].update()
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      p5.setup()
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/PathfindingMaze/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'
const GOOGLE_RED = '#DB4437'
const GOOGLE_YELLOW = '#F4B400'
const GOOGLE_GREEN = '#0F9D58'

class Spot {
  p5: P5
  i: number
  j: number
  f = 0
  g = 0
  h = 0
  neighbors: Spot[] = []
  previous: Spot | undefined = undefined
  wall = false
  cols: number
  rows: number
  w: number // Add width/height for drawing
  h: number

  constructor(
    p5: P5,
    i: number,
    j: number,
    cols: number,
    rows: number,
    w: number,
    h: number
  ) {
    this.p5 = p5
    this.i = i
    this.j = j
    this.cols = cols
    this.rows = rows
    this.w = w
    this.h = h
  }

  show(color: string | P5.Color) {
    if (this.wall) {
      // Don't draw walls explicitly, let maze walls handle it
      // this.p5.fill(theme['vs-dark'].colors.black);
      // this.p5.noStroke();
      // this.p5.rect(this.i * this.w, this.j * this.h, this.w, this.h);
    } else if (color) {
      this.p5.fill(color)
      this.p5.noStroke()
      // Draw slightly smaller to not overlap maze lines
      this.p5.rect(
        this.i * this.w + 1,
        this.j * this.h + 1,
        this.w - 2,
        this.h - 2
      )
    }
  }

  addNeighbors(grid: Spot[][]) {
    this.neighbors = [] // Clear previous neighbors
    const i = this.i
    const j = this.j
    if (i < this.cols - 1) this.neighbors.push(grid[i + 1][j])
    if (i > 0) this.neighbors.push(grid[i - 1][j])
    if (j < this.rows - 1) this.neighbors.push(grid[i][j + 1])
    if (j > 0) this.neighbors.push(grid[i][j - 1])
  }
}

function heuristic(a: Spot, b: Spot): number {
  return a.p5.dist(a.i, a.j, b.i, b.j)
}

class Cell {
  p5: P5
  i: number
  j: number
  walls = [true, true, true, true]
  visited = false
  cols: number
  rows: number
  w: number

  constructor(
    p5: P5,
    i: number,
    j: number,
    cols: number,
    rows: number,
    w: number
  ) {
    this.p5 = p5
    this.i = i
    this.j = j
    this.cols = cols
    this.rows = rows
    this.w = w
  }

  checkNeighbors(grid: Cell[][]): Cell | undefined {
    const neighbors: Cell[] = []
    const top = grid[this.i]?.[this.j - 1]
    const right = grid[this.i + 1]?.[this.j]
    const bottom = grid[this.i]?.[this.j + 1]
    const left = grid[this.i - 1]?.[this.j]

    if (top && !top.visited) neighbors.push(top)
    if (right && !right.visited) neighbors.push(right)
    if (bottom && !bottom.visited) neighbors.push(bottom)
    if (left && !left.visited) neighbors.push(left)

    if (neighbors.length > 0) {
      const r = this.p5.floor(this.p5.random(0, neighbors.length))
      return neighbors[r]
    } else {
      return undefined
    }
  }

  highlight() {
    const x = this.i * this.w
    const y = this.j * this.w
    this.p5.noStroke()
    this.p5.fill(GOOGLE_YELLOW + '80')
    this.p5.rect(x, y, this.w, this.w)
  }

  show(wallColor: string | P5.Color) {
    const x = this.i * this.w
    const y = this.j * this.w
    this.p5.stroke(wallColor)
    this.p5.strokeWeight(1)

    if (this.walls[0]) this.p5.line(x, y, x + this.w, y) // Top
    if (this.walls[1]) this.p5.line(x + this.w, y, x + this.w, y + this.w) // Right
    if (this.walls[2]) this.p5.line(x + this.w, y + this.w, x, y + this.w) // Bottom
    if (this.walls[3]) this.p5.line(x, y + this.w, x, y) // Left

    // Don't fill visited cells, let A* colors show through
    // if (this.visited) {
    //   this.p5.noStroke();
    //   this.p5.fill(theme['vs-dark'].colors.editorBackground + '50');
    //   this.p5.rect(x, y, this.w, this.w);
    // }
  }
}

function removeWalls(a: Cell, b: Cell) {
  const x = a.i - b.i
  if (x === 1) {
    a.walls[3] = false // a's left wall removed
    b.walls[1] = false // b's right wall removed
  } else if (x === -1) {
    a.walls[1] = false // a's right wall removed
    b.walls[3] = false // b's left wall removed
  }
  const y = a.j - b.j
  if (y === 1) {
    a.walls[0] = false // a's top wall removed
    b.walls[2] = false // b's bottom wall removed
  } else if (y === -1) {
    a.walls[2] = false // a's bottom wall removed
    b.walls[0] = false // b's top wall removed
  }
}

const sketch =
  (appTheme: Theme) =>
  (p5: P5): void => {
    const cols = 25
    const rows = 25
    let grid: Spot[][] = []
    let mazeGrid: Cell[][] = []

    let openSet: Spot[] = []
    let closedSet: Spot[] = []
    let start: Spot
    let end: Spot
    let w: number, h: number
    let path: Spot[] = []
    let generatingMaze = true
    let currentMazeCell: Cell | undefined
    const mazeStack: Cell[] = []
    let aStarRunning = false // Flag to control A* execution

    function setupMaze() {
      mazeGrid = new Array(cols)
      for (let i = 0; i < cols; i++) {
        mazeGrid[i] = new Array(rows)
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          mazeGrid[i][j] = new Cell(p5, i, j, cols, rows, w)
        }
      }
      currentMazeCell = mazeGrid[0][0]
      currentMazeCell.visited = true
      mazeStack.push(currentMazeCell)
      generatingMaze = true
      aStarRunning = false // Reset A* flag
      path = [] // Clear previous path
      openSet = []
      closedSet = []
    }

    function generateMazeStep() {
      if (!currentMazeCell) return

      currentMazeCell.visited = true
      const next = currentMazeCell.checkNeighbors(mazeGrid)
      if (next) {
        next.visited = true
        mazeStack.push(currentMazeCell)
        removeWalls(currentMazeCell, next)
        currentMazeCell = next
      } else if (mazeStack.length > 0) {
        currentMazeCell = mazeStack.pop()
      } else {
        generatingMaze = false
        console.log('Maze generated!')
        initializeAStar()
      }
    }

    function initializeAStar() {
      grid = new Array(cols)
      for (let i = 0; i < cols; i++) {
        grid[i] = new Array(rows)
      }

      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          // Pass w and h to Spot constructor
          grid[i][j] = new Spot(p5, i, j, cols, rows, w, h)
        }
      }

      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          grid[i][j].addNeighbors(grid)
        }
      }

      start = grid[0][0]
      end = grid[cols - 1][rows - 1]
      start.wall = false
      end.wall = false

      openSet = []
      closedSet = []
      path = []
      openSet.push(start)
      aStarRunning = true // Start A*
    }

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      w = p5.width / cols
      h = p5.height / rows
      setupMaze()
    }

    function runAStarStep() {
      if (!aStarRunning || openSet.length === 0) {
        if (openSet.length === 0 && aStarRunning) {
          console.log('No solution')
          aStarRunning = false // Stop trying if no solution
        }
        return // Stop if not running or no nodes left
      }

      let winner = 0
      for (let i = 0; i < openSet.length; i++) {
        if (openSet[i].f < openSet[winner].f) {
          winner = i
        }
      }
      const current = openSet[winner]

      if (current === end) {
        path = []
        let temp: Spot | undefined = current
        while (temp) {
          // Reconstruct path correctly
          path.push(temp)
          temp = temp.previous
        }
        console.log('DONE!')
        aStarRunning = false // Stop A* once path is found
        return // Path found, stop processing A* for this frame
      }

      openSet.splice(winner, 1)
      closedSet.push(current)

      const neighbors = current.neighbors
      for (let i = 0; i < neighbors.length; i++) {
        const neighbor = neighbors[i]

        if (!closedSet.includes(neighbor)) {
          // Check only closedSet
          const cellCurrent = mazeGrid[current.i][current.j]
          const cellNeighbor = mazeGrid[neighbor.i][neighbor.j]
          let wallBetween = false
          const x = current.i - neighbor.i
          const y = current.j - neighbor.j

          if (x === 1 && cellCurrent.walls[3]) wallBetween = true
          else if (x === -1 && cellCurrent.walls[1]) wallBetween = true
          else if (y === 1 && cellCurrent.walls[0]) wallBetween = true
          else if (y === -1 && cellCurrent.walls[2]) wallBetween = true

          if (wallBetween) continue

          const tempG = current.g + heuristic(neighbor, current)

          let newPath = false
          if (openSet.includes(neighbor)) {
            if (tempG < neighbor.g) {
              neighbor.g = tempG
              newPath = true
            }
          } else {
            neighbor.g = tempG
            newPath = true
            openSet.push(neighbor)
          }

          if (newPath) {
            neighbor.h = heuristic(neighbor, end)
            neighbor.f = neighbor.g + neighbor.h
            neighbor.previous = current
          }
        }
      }
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency

      // Draw maze grid first
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          mazeGrid[i][j].show(appTheme.colors.subString + '80') // Subtle maze walls
        }
      }

      if (generatingMaze) {
        currentMazeCell?.highlight()
        generateMazeStep()
      } else {
        // Run A* step
        runAStarStep()

        // Draw A* sets
        for (let i = 0; i < closedSet.length; i++) {
          closedSet[i].show(GOOGLE_RED + '50')
        }
        for (let i = 0; i < openSet.length; i++) {
          openSet[i].show(GOOGLE_GREEN + '50')
        }

        // Draw the path
        p5.noFill()
        p5.stroke(GOOGLE_BLUE)
        p5.strokeWeight(w / 3) // Thinner path
        p5.beginShape()
        // Draw path from start to end
        for (let i = path.length - 1; i >= 0; i--) {
          p5.vertex(path[i].i * w + w / 2, path[i].j * h + h / 2)
        }
        p5.endShape()

        // Draw start and end points distinctly on top
        start?.show(GOOGLE_GREEN)
        end?.show(GOOGLE_RED)
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      w = p5.width / cols
      h = p5.height / rows
      setupMaze() // Reinitialize everything
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/README.md
""""""
This directory contains various P5.js sketches used for animations within the application, primarily for loading indicators and the "Extensions" demonstration panel.

## Structure

-   **`index.ts`**: Exports a `SketchFactory` type definition. Sketch metadata is now managed in `src/assets/sketchMetadata.ts`.
-   **Individual Sketch Directories (e.g., `SnowFlakes/`, `DoublePendulum/`)**: Each directory typically contains an `index.ts` file that defines and exports a single sketch factory function.

## Sketch Factory

Each sketch is defined as a *factory function* that takes the current theme object as an argument and returns the actual P5.js sketch function. This allows sketches to adapt their appearance (e.g., colors) based on the selected theme.

The signature is:
`(theme: Theme) => (p5: P5) => void`

The inner function `(p5: P5) => void` is the standard P5.js instance mode setup, containing `setup` and `draw` methods.

## Available Sketches (Exposed via Extensions Panel)

-   **LinearConservation**: A single particle bouncing with gravity, demonstrating basic physics.
-   **SnowFlakes**: Particles simulating falling snowflakes.
-   **DoublePendulum**: Simulates the chaotic motion of a double pendulum with a tracing effect.
-   **HexagonCollision**: Features spinning hexagons releasing triangles that undergo elastic collisions.
-   **Starfield**: Creates a visual effect simulating high-speed travel through space using Google colors.
-   **PathfindingMaze**: Generates a random maze and visualizes the A* pathfinding algorithm finding a route.
-   **Hypercube**: Renders a rotating 4-dimensional hypercube (tesseract) projected into 3D/2D space.
-   **GoogleFlowField**: Particles follow paths defined by a Perlin noise field, colored using the Google palette.
-   **BoidsSimulation**: Simulates flocking behavior (separation, alignment, cohesion) among agents (boids) using Google colors.
-   **GameOfLife**: Implements Conway's Game of Life cellular automaton using Google colors.
-   **Metaballs**: Creates an organic, "gooey" visual effect where circular shapes merge smoothly, using Google colors.
-   **FourierDrawing**: Visualizes Fourier series by drawing complex shapes using rotating vectors (epicycles).

*(Note: `Bouncing` sketch is still used internally for the loading animation but is not listed in the Extensions panel).*

## Adding New Sketches

1.  Create a new directory (e.g., `MyNewSketch/`).
2.  Inside, create `index.ts`.
3.  Define your sketch factory function following the signature `(theme: Theme) => (p5: P5) => void`. Use the `theme` object to access colors if needed. Import `Body` and `Calculator` from `../Engine` if physics simulation is required.
4.  Export the factory function as default from `MyNewSketch/index.ts`.
5.  Import the new sketch factory into `src/components/Core/AnimationOverlay/index.tsx` and add it to the `sketchFactoryMap`.
6.  Add metadata (name, description, icon path) for the new sketch to the `sketchs` array in `src/assets/sketchMetadata.ts`. Remember to create a corresponding icon in `public/icons/`.

## Usage

Sketches are primarily rendered using the `AnimationOverlay` component (`src/components/Core/AnimationOverlay/index.tsx`), which handles dynamic loading, P5.js instance creation, display in a modal, and cleanup. The `Loading` component and the `Extensions` panel in the `SideBar` trigger the `AnimationOverlay`. The `Canvas` component (`src/components/Core/Canvas/index.tsx`) can still be used for embedding sketches directly within other components if needed.

## Related READMEs

-   [Core Components README](../README.md)
-   [Engine README](../Engine/README.md)
-   [Root README](../../../../README.md)
-   [Animation Context README](../../../contexts/README.md)
""""""


File: src/components/Core/Sketchs/ReactionDiffusion/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_GREEN = '#0F9D58'
const GOOGLE_YELLOW = '#F4B400'

interface Cell {
  a: number
  b: number
}

const sketch =
  (appTheme: Theme) =>
  (p5: P5): void => {
    let grid: Cell[][]
    let next: Cell[][]
    const dA = 1.0
    const dB = 0.5
    const feed = 0.055
    const k = 0.062
    const dt = 1.0

    function initGrid() {
      const w = p5.width
      const h = p5.height
      grid = new Array(w)
      for (let i = 0; i < w; i++) {
        grid[i] = new Array(h)
      }
      next = new Array(w)
      for (let i = 0; i < w; i++) {
        next[i] = new Array(h)
      }

      for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
          grid[x][y] = { a: 1, b: 0 }
          next[x][y] = { a: 1, b: 0 }
        }
      }

      const centerSize = 10
      const startX = p5.floor(w / 2 - centerSize / 2)
      const startY = p5.floor(h / 2 - centerSize / 2)
      for (let i = startX; i < startX + centerSize; i++) {
        for (let j = startY; j < startY + centerSize; j++) {
          if (i >= 0 && i < w && j >= 0 && j < h) {
            grid[i][j].b = 1
          }
        }
      }
    }

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight)
      p5.pixelDensity(1)
      initGrid()
    }

    function laplaceA(x: number, y: number): number {
      let sumA = 0
      sumA += grid[x][y].a * -1
      sumA += (grid[x - 1]?.[y]?.a ?? grid[x][y].a) * 0.2 // Edge handling: use center value
      sumA += (grid[x + 1]?.[y]?.a ?? grid[x][y].a) * 0.2
      sumA += (grid[x]?.[y + 1]?.a ?? grid[x][y].a) * 0.2
      sumA += (grid[x]?.[y - 1]?.a ?? grid[x][y].a) * 0.2
      sumA += (grid[x - 1]?.[y - 1]?.a ?? grid[x][y].a) * 0.05
      sumA += (grid[x + 1]?.[y - 1]?.a ?? grid[x][y].a) * 0.05
      sumA += (grid[x + 1]?.[y + 1]?.a ?? grid[x][y].a) * 0.05
      sumA += (grid[x - 1]?.[y + 1]?.a ?? grid[x][y].a) * 0.05
      return sumA
    }

    function laplaceB(x: number, y: number): number {
      let sumB = 0
      sumB += grid[x][y].b * -1
      sumB += (grid[x - 1]?.[y]?.b ?? grid[x][y].b) * 0.2 // Edge handling
      sumB += (grid[x + 1]?.[y]?.b ?? grid[x][y].b) * 0.2
      sumB += (grid[x]?.[y + 1]?.b ?? grid[x][y].b) * 0.2
      sumB += (grid[x]?.[y - 1]?.b ?? grid[x][y].b) * 0.2
      sumB += (grid[x - 1]?.[y - 1]?.b ?? grid[x][y].b) * 0.05
      sumB += (grid[x + 1]?.[y - 1]?.b ?? grid[x][y].b) * 0.05
      sumB += (grid[x + 1]?.[y + 1]?.b ?? grid[x][y].b) * 0.05
      sumB += (grid[x - 1]?.[y + 1]?.b ?? grid[x][y].b) * 0.05
      return sumB
    }

    p5.draw = () => {
      // No clear() or background() needed as we write every pixel

      // Calculate next state for each cell (handle edges better)
      for (let x = 0; x < p5.width; x++) {
        for (let y = 0; y < p5.height; y++) {
          const a = grid[x][y].a
          const b = grid[x][y].b

          next[x][y].a =
            a + (dA * laplaceA(x, y) - a * b * b + feed * (1 - a)) * dt
          next[x][y].b =
            b + (dB * laplaceB(x, y) + a * b * b - (k + feed) * b) * dt

          next[x][y].a = p5.constrain(next[x][y].a, 0, 1)
          next[x][y].b = p5.constrain(next[x][y].b, 0, 1)
        }
      }

      p5.loadPixels()
      for (let x = 0; x < p5.width; x++) {
        for (let y = 0; y < p5.height; y++) {
          const pix = (x + y * p5.width) * 4
          const a = next[x][y].a
          const b = next[x][y].b

          // Use a slightly different color mapping for better visibility
          const yellow = p5.color(GOOGLE_YELLOW)
          const green = p5.color(GOOGLE_GREEN)
          const bgColor = p5.color(appTheme.colors.editorBackground) // Get theme background

          // Interpolate between background and chemical color based on concentration
          let finalColor: P5.Color
          if (a > b) {
            finalColor = p5.lerpColor(bgColor, yellow, a)
          } else {
            finalColor = p5.lerpColor(bgColor, green, b)
          }

          p5.pixels[pix + 0] = p5.red(finalColor)
          p5.pixels[pix + 1] = p5.green(finalColor)
          p5.pixels[pix + 2] = p5.blue(finalColor)
          p5.pixels[pix + 3] = 255
        }
      }
      p5.updatePixels()

      const temp = grid
      grid = next
      next = temp
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      initGrid()
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/SnowFlakes/index.ts
""""""
import Calculator from 'src/components/Core/Engine/Calculator'
import Body from 'src/components/Core/Engine/Body'
import P5 from 'p5'
import theme from 'src/styles/theme'
type Theme = typeof theme['vs-dark']
const sketch =
  (_theme: Theme) =>
  (p5: P5): void => {
    const calculator = new Calculator()
    const maxBodies = 200
    const bodies: Body[] = []
    const forceField = { x: 0, y: 0.1 } // Gentle downward force

    const addNewRandomBody = (isInitial = false) => {
      const startY = isInitial
        ? p5.random(-p5.height, p5.height)
        : p5.random(-50, -10) // Start new ones above screen
      const startX = p5.random(-p5.width * 0.1, p5.width * 1.1) // Allow starting slightly off-screen horizontally
      const newBody = new Body(
        { x: startX, y: startY },
        { x: p5.random(-0.5, 0.5), y: p5.random(0.5, 1.5) }, // Initial velocity
        { x: 0, y: 0 }, // Initial acceleration
        p5.random(1, 4) // Use p5.random
      )
      bodies.push(newBody)
    }

    p5.setup = (w = p5.windowWidth, h = p5.windowHeight) => {
      // Use windowWidth/Height
      p5.createCanvas(w, h)
      bodies.length = 0 // Clear bodies on setup
      // Initial population
      for (let i = 0; i < maxBodies / 2; i++) {
        addNewRandomBody(true)
      }
    }

    p5.draw = () => {
      p5.clear() // Use clear() for transparency
      p5.frameRate(30) // Slightly smoother framerate

      // Add new snowflakes gradually if below max
      if (bodies.length < maxBodies && p5.frameCount % 5 === 0) {
        // Add one every 5 frames
        addNewRandomBody()
      }

      // Wind effect (simple horizontal force based on noise)
      const wind = (p5.noise(p5.frameCount * 0.01) - 0.5) * 0.1

      for (let i = bodies.length - 1; i >= 0; i--) {
        const body = bodies[i]
        body.color = [220, 220, 220, 200] // Slightly transparent white

        // Apply forces (gravity + wind)
        const gravity = p5.createVector(forceField.x, forceField.y)
        gravity.mult(body.mass * 0.5) // Heavier flakes fall slightly faster
        const windForce = p5.createVector(wind, 0)
        body.applyForce(gravity)
        body.applyForce(windForce)

        body.update({ x: 0, y: 0 }) // Update applies accumulated acceleration
        body.UpdateCoordinates() // Update position based on velocity
        body.draw(p5)

        // Remove snowflakes that fall below the screen
        if (body.coordinates.y > p5.height + body.mass * 5) {
          bodies.splice(i, 1)
        }
        // Wrap around horizontally (optional)
        // if (body.coordinates.x < -body.mass * 5) body.coordinates.x = p5.width + body.mass * 5;
        // if (body.coordinates.x > p5.width + body.mass * 5) body.coordinates.x = -body.mass * 5;
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight)
      p5.setup(p5.windowWidth, p5.windowHeight) // Re-run setup
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/Starfield/index.ts
""""""
import type P5 from 'p5' // Use type import
import theme from 'src/styles/theme'

type Theme = typeof theme['vs-dark']

const GOOGLE_BLUE = '#4285F4'
const GOOGLE_RED = '#DB4437'
const GOOGLE_YELLOW = '#F4B400'
const GOOGLE_GREEN = '#0F9D58'
const GOOGLE_COLORS = [GOOGLE_BLUE, GOOGLE_RED, GOOGLE_YELLOW, GOOGLE_GREEN]

class Star {
  p5: P5
  x: number
  y: number
  z: number
  pz: number // Previous Z
  maxSpeed: number
  width: number
  height: number
  color: string // Store the star's color

  constructor(p5: P5, width: number, height: number, maxSpeed: number) {
    this.p5 = p5
    this.width = width
    this.height = height
    this.maxSpeed = maxSpeed
    this.x = p5.random(-width / 2, width / 2)
    this.y = p5.random(-height / 2, height / 2)
    this.z = p5.random(width) // Start stars at different depths
    this.pz = this.z
    this.color = p5.random(GOOGLE_COLORS) // Assign a random Google color
  }

  update(speed: number) {
    this.z = this.z - speed
    if (this.z < 1) {
      // Reset star when it goes past the screen
      this.z = this.width
      this.x = this.p5.random(-this.width / 2, this.width / 2)
      this.y = this.p5.random(-this.height / 2, this.height / 2)
      this.pz = this.z
      this.color = this.p5.random(GOOGLE_COLORS) // Reassign color on reset
    }
  }

  show() {
    this.p5.fill(this.color) // Use the star's assigned color
    this.p5.noStroke()

    // Project 3D position to 2D screen coordinates
    const sx = this.p5.map(this.x / this.z, 0, 1, 0, this.width)
    const sy = this.p5.map(this.y / this.z, 0, 1, 0, this.height)

    // Calculate star size based on distance
    // const r = this.p5.map(this.z, 0, this.width, 8, 0); // Closer stars are bigger
    // this.p5.ellipse(sx, sy, r, r); // Drawing ellipse is optional

    // Calculate previous screen position for the trail
    const px = this.p5.map(this.x / this.pz, 0, 1, 0, this.width)
    const py = this.p5.map(this.y / this.pz, 0, 1, 0, this.height)

    this.pz = this.z // Update previous z for next frame

    // Draw the trail
    this.p5.stroke(this.color) // Use the star's color for the trail
    const speed = this.p5.abs(this.maxSpeed) // Use absolute speed for stroke weight mapping
    const strokeWeight = this.p5.map(speed, 0, this.maxSpeed, 1, 3) // Thicker trail at higher speeds
    this.p5.strokeWeight(strokeWeight)
    this.p5.line(px, py, sx, sy)
  }
}

const sketch =
  (
    _theme: Theme // Theme is not used directly here anymore
  ) =>
  (p5: P5): void => {
    const stars: Star[] = []
    const numStars = 800
    let speed: number

    p5.setup = () => {
      p5.createCanvas(p5.windowWidth, p5.windowHeight) // Use window dimensions
      stars.length = 0 // Clear stars on setup
      for (let i = 0; i < numStars; i++) {
        stars[i] = new Star(p5, p5.width, p5.height, 50) // Max speed 50
      }
    }

    p5.draw = () => {
      speed = 20 // Fixed speed example
      p5.clear() // Use clear() for transparency instead of background()
      p5.translate(p5.width / 2, p5.height / 2) // Center the origin

      for (let i = 0; i < stars.length; i++) {
        stars[i].update(speed)
        stars[i].show() // Pass theme if needed by show()
      }
    }

    p5.windowResized = () => {
      p5.resizeCanvas(p5.windowWidth, p5.windowHeight) // Resize to window dimensions
      // Reinitialize stars for new dimensions
      stars.length = 0 // Clear existing stars
      for (let i = 0; i < numStars; i++) {
        stars[i] = new Star(p5, p5.width, p5.height, 50)
      }
    }
  }

export default sketch
""""""


File: src/components/Core/Sketchs/index.ts
""""""
import type P5 from 'p5'
import theme from 'src/styles/theme'

// Define Theme type locally or import from styles
type Theme = typeof theme['vs-dark']

// Helper type for sketch factory functions - Keep this type definition
export type SketchFactory = (theme: Theme) => (p5: P5) => void

// Removed the sketchs array export from here
""""""


File: src/components/Core/Splittable/index.tsx
""""""
import { ReactNode } from 'react'
import { StyledPanelGroup, StyledPanel, StyledResizeHandle } from './styled'
import useWindowSize from 'src/hooks/useWindow'

type Direction = 'horizontal' | 'vertical'

interface SplittableContainerProps {
  defaultLayout?: number[]
  direction?: Direction
  targetView: ReactNode
  newView?: ReactNode
  id: number
}

const SplittableContainer: React.FC<SplittableContainerProps> = ({
  direction = 'horizontal',
  targetView,
  newView,
  id
}) => {
  const { isMedium } = useWindowSize()

  return (
    <StyledPanelGroup
      direction={isMedium ? 'vertical' : direction}
      id={`${id}`}
    >
      {newView && (
        <StyledPanel order={id + 1} defaultSize={25}>
          {newView}
        </StyledPanel>
      )}

      {!isMedium && newView && targetView && (
        <StyledResizeHandle direction={direction} />
      )}
      {targetView && (
        <StyledPanel order={id + 2} defaultSize={newView ? 50 : 100}>
          {targetView}
        </StyledPanel>
      )}
    </StyledPanelGroup>
  )
}

export default SplittableContainer
""""""


File: src/components/Core/Splittable/styled.ts
""""""
import styled from 'styled-components'
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels'

type Direction = 'horizontal' | 'vertical'

export const StyledPanelGroup = styled(PanelGroup)<{ direction: Direction }>`
  width: 100%;
  max-width: 100%;
  height: 400px;
  overflow: hidden;

  ${({ direction }) =>
    direction === 'vertical' &&
    `
    flex-direction: column;
  `}
`

export const StyledPanel = styled(Panel)`
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 24px;
  color: #888;
  min-width: 300px;
`

export const StyledResizeHandle = styled(PanelResizeHandle)<{
  direction: Direction
}>`
  background-color: #aaa;
  z-index: 10;
  cursor: ${({ direction }) =>
    direction === 'horizontal' ? 'col-resize' : 'row-resize'};
  width: ${({ direction }) => (direction === 'horizontal' ? '1px' : '100%')};
  height: ${({ direction }) => (direction === 'horizontal' ? '100%' : '1px')};
  opacity: 0.2;
`
""""""


File: src/components/Core/Text/index.tsx
""""""
import theme from 'src/styles/theme'
import styled from 'styled-components'

const colors = theme?.['vs-dark'].colors

export type TextProps = {
  weight?: string
  font?: string
  size?: number
  color?: keyof typeof colors
  children?: JSX.Element | JSX.Element[] | string | number | string[] | number[]
  capitalize?: string
  uppercase?: string
  letterSpacing?: string
  lineHeight?: string
  opacity?: string
  fontStyle?: string
  clickable?: string
  as?: 'p' | 'h1' | 'h2' | 'h3' | 'span' | 'pre'
}

const Text = styled.p<TextProps>`
  margin: 0;
  font-weight: ${({ weight }) => weight};
  font-family: ${({ font }) => font};
  font-size: ${({ size }) => `${size}px`};
  line-height: ${({ lineHeight }) => lineHeight && `${lineHeight}px`};
  letter-spacing: ${({ letterSpacing }) =>
    letterSpacing && `${letterSpacing}px`};
  color: ${({ color, theme }) => color && theme.colors[color]};
  cursor: ${({ clickable }) => clickable && 'pointer'};
  text-transform: ${({ capitalize, uppercase }) =>
    capitalize ? 'capitalize' : uppercase ? 'uppercase' : 'inherit'};
  opacity: ${({ opacity }) => opacity};
`

const TextComponent: React.FC<TextProps> = ({
  weight,
  font,
  size,
  children,
  capitalize,
  uppercase,
  letterSpacing,
  lineHeight,
  opacity,
  fontStyle,
  clickable,
  color = 'text',
  as = 'p',
  ...rest
}) => {
  return (
    <Text
      as={as}
      weight={weight}
      font={font}
      size={size}
      color={color}
      capitalize={capitalize}
      uppercase={uppercase}
      letterSpacing={letterSpacing}
      lineHeight={lineHeight}
      opacity={opacity}
      fontStyle={fontStyle}
      clickable={clickable}
      {...rest}
    >
      {children}
    </Text>
  )
}

export default TextComponent
""""""


File: src/components/Core/TileFile/index.tsx
""""""
import { Container, ArrowIcon, ArrowContainer } from './styled'
import Text from 'src/components/Core/Text'
import { useExtension } from 'src/hooks/useExtension'
import useContextFile from 'src/hooks/useContextFile'

export type FileTileProps = {
  filePath: string
  folder: boolean
  open: boolean
}

const FileTile: React.FC<FileTileProps> = ({ filePath, folder, open }) => {
  const { extractIcon } = useExtension()
  const { files } = useContextFile()
  const file = files.find(file => file.path === filePath)
  const Icon = extractIcon(filePath, open, folder)
  const { diff, isDiff } = file ?? {}

  const handleDragStart = (e: React.DragEvent<HTMLDivElement>) => {
    e.dataTransfer.setData('file', JSON.stringify(filePath))
  }

  return (
    <Container
      data-tut={
        file?.name?.includes('resume')
          ? 'resume_folder'
          : file?.name === process.env.REPO
          ? 'repo_folder'
          : ''
      }
      draggable={!folder}
      onDragStart={handleDragStart}
    >
      <ArrowContainer>
        {folder && <ArrowIcon height="10px" width="10px" open={open} />}
      </ArrowContainer>
      <Icon height="14px" width="14px" />
      <Text size={14}>{file?.name}</Text>
      {isDiff && <Text size={13}>(Working Tree)</Text>}
      {diff && <Text size={13}>M</Text>}
    </Container>
  )
}

export default FileTile
""""""


File: src/components/Core/TileFile/styled.ts
""""""
import styled from 'styled-components'
import Arrow from 'public/icons/arrow.svg'

export const Container = styled.div`
  display: grid;
  grid-template-columns: max-content max-content max-content max-content max-content;
  grid-gap: 5px;
  padding: 1px;
  padding-right: 10px;
  padding-left: 10px;
  align-items: center;
`
export const ArrowContainer = styled.div``

export const ArrowIcon = styled(Arrow)`
  transform: ${({ open }) => !open && 'rotate(-90deg)'};
  fill: ${({ theme }) => theme.colors.text};
`
""""""


File: src/components/Home/FileView/Background/index.tsx
""""""
import { useEffect } from 'react'
import Text from 'src/components/Core/Text'
import useContextTheme from 'src/hooks/useContextTheme'
import useContextLoading from 'src/hooks/useLoading'
import { Container, Content, VS, SpanHighlighted } from './styled'
import { useContextPrint } from 'src/hooks/useContextPrint'
import { useWindowSize } from 'src/hooks/useWindow'
import { useContextGuideTour } from 'src/hooks/useGuideTour'
const Background: React.FC = () => {
  const { setTour } = useContextGuideTour()
  const { isMedium } = useWindowSize()
  const { print } = useContextPrint()
  const { toggleTheme, selectedTheme } = useContextTheme()
  const { flashLoading, loading } = useContextLoading()

  const handleKeyUp = (event: KeyboardEvent) => {
    const { ctrlKey, key } = event

    if (ctrlKey) {
      key === 'Q' && toggleTheme()
      key === 'q' && toggleTheme()
      key === 'p' && print && print()
      key === 'P' && print && print()
      key === '@' &&
        (() => {
          setTour(true)
        })()
      key === ' ' && !loading && flashLoading()
    }
  }

  useEffect(() => {
    window.addEventListener('keydown', handleKeyUp)
    return () => window.removeEventListener('keydown', handleKeyUp)
  }, [selectedTheme, loading])

  return (
    <Container>
      <VS data-tut="profile" />
      {!isMedium && (
        <Content>
          <Text size={13}>
            <span>
              Toggle Theme
              <SpanHighlighted as="span">CTRL</SpanHighlighted>+
              <SpanHighlighted as="span">Q</SpanHighlighted>
            </span>
          </Text>
          <Text size={13}>
            <span>
              Print / Download Resume
              <SpanHighlighted as="span">CTRL</SpanHighlighted>+
              <SpanHighlighted as="span">P</SpanHighlighted>
            </span>
          </Text>

          <Text size={13}>
            <span>
              Restart Tour
              <SpanHighlighted as="span">CTRL</SpanHighlighted>+
              <SpanHighlighted as="span">SHIFT</SpanHighlighted>+
              <SpanHighlighted as="span">2</SpanHighlighted>
            </span>
          </Text>
          <Text size={13}>
            <span>
              Flash a Loading Sketch
              <SpanHighlighted as="span">CTRL</SpanHighlighted>+
              <SpanHighlighted as="span">SPACE</SpanHighlighted>
            </span>
          </Text>
        </Content>
      )}
    </Container>
  )
}

export default Background
""""""


File: src/components/Home/FileView/Background/styled.ts
""""""
import styled from 'styled-components'
import Image from 'next/image'
import Text from 'src/components/Core/Text'

export const Img = styled(Image)`
  box-shadow: 3px 3px red, -1em 0 0.4em olive;
`

export const SpanHighlighted = styled(Text)`
  background-color: ${({ theme }) => theme.colors.shortCut};
  border-radius: 2px;
  padding: 2px 6px;
  margin: 0px 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25), 0 2px 2px rgba(0, 0, 0, 0.22);
`

export const Container = styled.div`
  display: grid;
  grid-gap: 50px;
  grid-template-rows: max-content max-content;
  justify-content: center;
  justify-items: center;
  align-content: center;
  align-items: center;
  height: 100%;
  text-align: center;
`

export const Content = styled.div`
  display: grid;
  grid-gap: 12px;
`

export const VS = styled.div`
  background: url(/profisionalProfile.png);
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  height: 280px;
  width: 280px;
  clip-path: polygon(
    9% 76%,
    0 67%,
    16% 50%,
    0 34%,
    9% 24%,
    15% 27%,
    29% 38%,
    71% 1%,
    83% 4%,
    98% 12%,
    100% 87%,
    76% 99%,
    70% 99%,
    29% 62%
  );
  @media (max-width: ${({ theme }) => theme.breakpoints.medium}) {
    height: 200px;
    width: 200px;
  }
  @media (max-width: ${({ theme }) => theme.breakpoints.xSmall}) {
    height: 120px;
    width: 120px;
  }
`
""""""


File: src/components/Home/FileView/CurrentFile/index.tsx
""""""
import { useEffect, useState } from 'react'
import githubService from 'src/services/github'
import useExtension from 'src/hooks/useExtension'
import useContextLoading from 'src/hooks/useLoading'
import useContextFile from 'src/hooks/useContextFile'
import useContextFileView from 'src/hooks/useContextFileView'
import CoreEditor from 'src/components/Core/Editor'
import DiffEditor from 'src/components/Core/DiffEditor'
import { FileType } from 'src/reducers/FileReducer'

const Editor: React.FC<{ id: number }> = ({ id }) => {
  const { fetchFileContent } = githubService
  const { extractExtension } = useExtension()
  const { setLoading } = useContextLoading()

  const { setContent, setNewContent, setImage, files } = useContextFile()

  const rootContext = useContextFileView()
  const { findNodeById } = rootContext
  const subTree = findNodeById(id, rootContext)
  if (!subTree) return null
  const { currentFile } = subTree

  const [currentContent, setCurrentContent] = useState('')

  const currentFileData = files.find(file => file.path === currentFile)

  const handleFetchFileContent = async (fileData: FileType, path: string) => {
    setLoading(true)
    const data = await fetchFileContent(path)
    const isImage = /\.(png|jpg|jpeg|ico)$/i.test(path)

    if (isImage) {
      if (!fileData.image) {
        const imageElement = (
          <div
            style={{
              position: 'absolute',
              top: '0%',
              left: '0%',
              height: '100%',
              width: '100%',
              zIndex: 9,
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center'
            }}
          >
            <img
              placeholder="blur"
              src={` data:image/jpeg;charset=utf-8;base64, ${data.content}`}
            />
          </div>
        )
        setImage(fileData, imageElement)
      }
    } else {
      const rawFile = decodeURIComponent(escape(window.atob(data.content)))
      setContent(fileData, rawFile)
      setCurrentContent(rawFile) // Set content directly here to avoid extra re-render
    }
    setLoading(false) // Set loading to false once the content is fetched and set
  }

  useEffect(() => {
    if (
      currentFileData &&
      !currentFileData.content &&
      !currentFileData.image &&
      currentFileData.path
    ) {
      handleFetchFileContent(currentFileData, currentFileData.path)
    } else if (
      currentFileData &&
      (currentFileData.content || currentFileData.image)
    ) {
      setCurrentContent(currentFileData.content || '')
    }
  }, [currentFileData, currentFile])

  const currentExt = extractExtension(currentFileData?.path || 'default.json')

  return (
    <>
      {currentFile && currentFileData && !currentFileData.image && (
        <>
          {!currentFileData.isDiff ? (
            <CoreEditor
              onChange={currentValue =>
                setNewContent(currentFileData, currentValue || '')
              }
              currentContent={currentContent}
              currentExt={currentExt}
            />
          ) : (
            <DiffEditor
              currentContent={currentFileData.content || ''}
              currentNewContent={currentFileData.newContent || ''}
              currentExt={currentExt}
            />
          )}
        </>
      )}
      {currentFileData?.image}
    </>
  )
}

export default Editor
""""""


File: src/components/Home/FileView/index.tsx
""""""
import { Container, EditorContainer } from './styled'
import Background from './Background'
import CurrentFileEditor from './CurrentFile'
import GuideTour from 'src/components/Core/GuideTour'
import useContextFileView from 'src/hooks/useContextFileView'

const FileView: React.FC<{ id: number }> = ({ id }) => {
  const rootContext = useContextFileView()
  const { findNodeById } = rootContext
  const subTree = findNodeById(id, rootContext)
  if (!subTree) return null
  const { currentFile, openedFiles } = subTree

  return (
    <Container>
      <GuideTour />
      <Background />
      {openedFiles.map(file => (
        <EditorContainer key={file} currentFile={file === currentFile}>
          {file === currentFile && <CurrentFileEditor id={id} />}
        </EditorContainer>
      ))}
    </Container>
  )
}

export default FileView
""""""


File: src/components/Home/FileView/styled.ts
""""""
import styled from 'styled-components'

interface Props {
  currentFile: boolean
}

export const LoadingContainer = styled.div`
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
`

export const Container = styled.div`
  position: relative;
  height: 100%;
  max-height: 100%;
  width: 100%;
  box-sizing: border-box;
`

export const EditorContainer = styled.div<Pick<Props, 'currentFile'>>`
  display: ${({ currentFile }) => (currentFile ? 'flex' : 'none')};
  background-color: ${({ theme }) => theme.colors.editorBackground};
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
`
""""""


File: src/components/Home/FileViewComponent/index.tsx
""""""
import DragDropComponent from 'src/components/Core/DragDrop'
import useContextFileView from 'src/hooks/useContextFileView'
import { FileContainer, Main } from '../styled'
import Navigation from '../Navigation'
import Loading from 'src/components/Core/Loading'
import FileView from '../FileView'
import SplittableContainer from 'src/components/Core/Splittable'
import { FileViewsContextType, Orientation } from 'src/contexts/FileViewContext'
import { useEffect } from 'react'
import useContextFile from 'src/hooks/useContextFile'

interface FileViewComponentProps {
  depth?: number
  id: number
}

const FileViewComponent: React.FC<FileViewComponentProps> = ({
  depth = 0,
  id = 0
}) => {
  const rootContext = useContextFileView()
  const { findNodeById } = rootContext
  const subTree = findNodeById(id, rootContext)
  if (!subTree) return null
  const {
    children: childContext,
    openFile,
    createChild,
    orientation,
    setOrientation
  } = subTree

  const { setFocusedFileView } = useContextFile()

  const onPosition = (
    position: Orientation | 'center' | null,
    file: string
  ) => {
    const isNotEmpty =
      rootContext.children.length > 0 || rootContext.openedFiles.length > 0

    if (!position || position === 'center') {
      openFile(file, id)
    } else if (isNotEmpty) {
      createChild(file, position, id)
      setOrientation(position, id)
    } else {
      openFile(file, id)
    }
  }

  const initialFileview = (
    <DragDropComponent onPosition={onPosition}>
      <Main
        onClick={() => {
          setFocusedFileView(id)
        }}
        onDragEnd={() => {
          setFocusedFileView(id)
        }}
      >
        <Navigation id={id} />
        <FileContainer>
          <Loading />
          <FileView id={id} />
        </FileContainer>
      </Main>
    </DragDropComponent>
  )

  const renderChildren = (childrenContext: FileViewsContextType[]) => {
    return (
      <FileViewComponent
        key={childrenContext[0].id}
        depth={depth + 1}
        id={childrenContext[0].id}
      />
    )
  }

  useEffect(() => {
    setFocusedFileView(id)
  }, [])

  // Determine direction based on orientation
  const direction =
    orientation === 'right' || orientation === 'left'
      ? 'horizontal'
      : 'vertical'

  const firstChild = initialFileview
  const secondChild =
    childContext && childContext.length > 0
      ? renderChildren(childContext)
      : undefined

  const shouldSwap = orientation === 'right' || orientation === 'top'
  return (
    <>
      <SplittableContainer
        direction={direction}
        id={depth}
        targetView={shouldSwap ? secondChild ?? null : firstChild ?? null}
        newView={shouldSwap ? firstChild ?? null : secondChild ?? null}
      />
    </>
  )
}

export default FileViewComponent
""""""


File: src/components/Home/Footer/index.tsx
""""""
import { Container, Content, Info } from './styled'
import Text from 'src/components/Core/Text'
import CheckIcon from 'public/icons/check.svg'
import SourceIcon from 'public/icons/source.svg'
import { useWindowSize } from 'src/hooks/useWindow'

const Footer: React.FC = () => {
  const { isMedium } = useWindowSize()
  return (
    <Container>
      <Content>
        <Info>
          <SourceIcon />
          <Text color="white" weight="600" size={13}>
            main
          </Text>
        </Info>
        <Info>
          <CheckIcon />
          <Text color="white" weight="600" size={13}>
            Typescript
          </Text>
        </Info>
      </Content>
      {!isMedium && (
        <Content>
          <Info>
            <CheckIcon />
            <Text color="white" weight="600" size={13}>
              ESLint
            </Text>
          </Info>
          <Info>
            <CheckIcon />
            <Text color="white" weight="600" size={13}>
              Prettier
            </Text>
          </Info>
        </Content>
      )}
    </Container>
  )
}

export default Footer
""""""


File: src/components/Home/Footer/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  background-color: ${({ theme }) => theme.colors.vsBlue};
  display: flex;
  justify-content: space-between;
  padding: 0px 20px;
  height: 1.5rem;
  z-index: 999;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
`

export const Info = styled.div`
  display: grid;
  grid-template-columns: repeat(2, max-content);
  grid-gap: 5px;

  justify-content: center;
  align-items: center;
`

export const Content = styled.div`
  display: grid;
  grid-template-columns: repeat(2, max-content);
  grid-gap: 20px;
  svg {
    height: 12px;
    width: 12px;
  }
`
""""""


File: src/components/Home/Navigation/index.tsx
""""""
import { Container, Row, Close } from './styled'
import useContextFileView from 'src/hooks/useContextFileView'
import FileTile from 'src/components/Core/TileFile'
import CloseIcon from 'public/icons/close-line.svg'

const Navigation: React.FC<{ id: number }> = ({ id }) => {
  const rootContext = useContextFileView()
  const { findNodeById } = rootContext

  const subTree = findNodeById(id, rootContext)
  if (!subTree) return null
  const { openedFiles, currentFile, openFile, closeFile } = subTree

  return (
    <Container>
      {openedFiles?.map(file => (
        <Row
          isCurrent={file === currentFile}
          onClick={() => {
            openFile(file, id)
          }}
          key={file}
        >
          <FileTile folder={false} open={false} filePath={file} />
          <Close
            onClick={e => {
              e.stopPropagation()
              closeFile(file, id)
            }}
          >
            <CloseIcon />
          </Close>
        </Row>
      ))}
    </Container>
  )
}

export default Navigation
""""""


File: src/components/Home/Navigation/styled.ts
""""""
import styled from 'styled-components'

interface Props {
  isCurrent: boolean
}

export const Container = styled.div`
  display: flex;
  max-width: 100%;
  overflow-x: auto;
`
export const Row = styled.div<Pick<Props, 'isCurrent'>>`
  cursor: pointer;
  display: grid;
  place-items: center;
  grid-template-columns: 1fr 10px;
  padding: 5px;
  padding-right: 8px;
  background-color: ${({ isCurrent, theme }) =>
    isCurrent
      ? theme.colors.selectedNavigationFile
      : theme.colors.navigationFile};
  border-right: 1px solid ${({ theme }) => theme.colors.tileBorder};
  border-bottom: ${({ isCurrent, theme }) =>
    isCurrent ? `1px solid ${theme.colors.accentColor}` : 'none'};

  div :last-child {
    display: none;
  }

  :hover {
    background-color: ${({ theme }) => theme.colors.selectedNavigationFile};
    div :last-child {
      display: grid;
    }
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.medium}) {
    div :last-child {
      display: grid;
    }
  }
`
export const Close = styled.div`
  display: grid;
  place-items: center;

  cursor: pointer;
  width: 18px;
  height: 18px;
  border-radius: 5px;
  :hover {
    background-color: ${({ theme }) => theme.colors.negativeHighlight};
  }
  @media (max-width: ${({ theme }) => theme.breakpoints.medium}) {
    background-color: ${({ theme }) => theme.colors.negativeHighlight};
  }

  svg {
    fill: ${({ theme }) => theme.colors.text};
    height: 8px;
    width: 8px;
  }
`
""""""


File: src/components/Home/SideBar/NavBar/index.tsx
""""""
import Icon from 'src/components/Core/Icons'
import { Section, Option, Container } from './styled'
import useSideBar from 'src/hooks/useSideBar'
import FloatMenu from 'src/components/Core/FloatMenu'
import useContextTheme from 'src/hooks/useContextTheme'
import { useContextPrint } from 'src/hooks/useContextPrint'
import { useContextGuideTour } from 'src/hooks/useGuideTour'
import { useState } from 'react'
import { sketchs } from 'src/assets/sketchMetadata' // <--- UPDATED IMPORT PATH
import dynamic from 'next/dynamic'

// Dynamically import AnimationOverlay, disable SSR
const DynamicAnimationOverlay = dynamic(
  () => import('src/components/Core/AnimationOverlay'),
  { ssr: false }
)

type Variant =
  | 'files'
  | 'search'
  | 'source'
  | 'debug'
  | 'extensions'
  | 'profile'
  | 'settings'

type OptionType = {
  variant: Variant
  onClick?: () => void
}

interface OptionMenu extends OptionType {
  options?: {
    labels: string[]
    onClick: () => void
  }[]
}

const NavBar: React.FC = () => {
  const { toggleTheme } = useContextTheme()
  const { setTour } = useContextGuideTour()
  const { selectedSection, setSelectedSection, setOpen, open } = useSideBar()
  const [showDebugAnimation, setShowDebugAnimation] = useState(false)
  const [debugSketchName, setDebugSketchName] = useState<string | null>(null)

  const playRandomAnimation = () => {
    console.log('[NavBar] playRandomAnimation called.')
    console.log('[NavBar] Checking sketchs value:', sketchs)
    if (Array.isArray(sketchs) && sketchs.length > 0) {
      const randomIndex = Math.floor(Math.random() * sketchs.length)
      const randomSketch = sketchs[randomIndex]
      if (randomSketch) {
        const sketchToPlay = randomSketch.name
        console.log(`[NavBar] Random sketch selected: ${sketchToPlay}`)
        console.log(
          `[NavBar] Setting state: debugSketchName=${sketchToPlay}, showDebugAnimation=true`
        )
        setDebugSketchName(sketchToPlay)
        setShowDebugAnimation(true)
      } else {
        console.error(
          '[NavBar] Could not select a random sketch (index issue?).'
        )
      }
    } else {
      console.warn(
        '[NavBar] No sketches available or sketchs not loaded correctly yet.'
      )
    }
  }

  const menuOptions: OptionType[] = [
    { variant: 'files' },
    { variant: 'search' },
    { variant: 'source' },
    {
      variant: 'debug',
      onClick: playRandomAnimation
    },
    { variant: 'extensions' }
  ]
  const { print } = useContextPrint()

  const menuExtras: OptionMenu[] = [
    {
      variant: 'profile',
      options: [
        {
          labels: ['Send me a Whatsapp'],
          onClick: () => {
            window.open(
              'https://web.whatsapp.com/send?phone=5537991640818&lang=en'
            )
          }
        },
        {
          labels: ['Send me a Email'],
          onClick: () => {
            window.open(
              'mailto:lgpelin92@gmail.com?subject=Contact from luisguilher.me'
            )
          }
        },
        {
          labels: ['Visit my Linkedin'],
          onClick: () => {
            window.open('https://www.linkedin.com/in/lguibr/')
          }
        },
        {
          labels: ['Visit my Github'],
          onClick: () => {
            window.open('https://github.com/lguibr')
          }
        },
        {
          labels: ['Print / Download Resume'],
          onClick: () => {
            print && print()
          }
        }
      ]
    },
    {
      variant: 'settings',
      options: [
        {
          labels: ['Toggle theme'],
          onClick: () => toggleTheme()
        },
        {
          labels: ['Restart the onboarding'],
          onClick: () => {
            setTour(true)
          }
        },
        {
          labels: ['Open project on Github'],
          onClick: () =>
            window?.open('https://github.com/lguibr/luisguilher.me')
        },
        {
          labels: ['Open a issue'],
          onClick: () =>
            window?.open('https://github.com/lguibr/luisguilher.me/issues/new')
        }
      ]
    }
  ]

  const handleClick = (selection: Variant): void => {
    const isSameSection = selectedSection === selection

    isSameSection && setOpen(!open)
    !isSameSection && setOpen(true)
    setSelectedSection(selection)
  }

  return (
    <>
      <Container>
        <Section>
          {menuOptions.map((option, index) => (
            <Option
              data-tut={`nav${index}`}
              isSelectedSection={selectedSection === option.variant}
              onClick={() => {
                handleClick(option.variant)
                option?.onClick && option?.onClick()
              }}
              key={option.variant}
            >
              <Icon variant={option.variant} height="30px" width="30px" />
            </Option>
          ))}
        </Section>
        <Section>
          {menuExtras.map((option, index) => (
            <Option
              data-tut={`extra${index}`}
              isSelectedSection={false}
              key={option.variant}
            >
              <FloatMenu options={option?.options}>
                <Icon variant={option.variant} height="30px" width="30px" />
              </FloatMenu>
            </Option>
          ))}
        </Section>
      </Container>
      {showDebugAnimation && debugSketchName && (
        <DynamicAnimationOverlay
          key={debugSketchName}
          sketchName={debugSketchName}
          onClose={() => {
            setShowDebugAnimation(false)
            setDebugSketchName(null)
          }}
        />
      )}
    </>
  )
}

export default NavBar
""""""


File: src/components/Home/SideBar/NavBar/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  background-color: ${({ theme }) => theme.colors.listDropBackground};
  z-index: 999;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  @media (max-width: ${({ theme }) => theme.breakpoints.medium}) {
    padding-bottom: 50px;
  }
`

export const Section = styled.div`
  width: 100%;
  display: flex;
  flex-direction: column;
`

interface OptionProp {
  isSelectedSection: boolean
}

export const Option = styled.div<OptionProp>`
  padding: 10px;
  border-left: ${({ theme, isSelectedSection }) =>
    isSelectedSection && `2px solid  ${theme.colors.accentColor}`};
`
""""""


File: src/components/Home/SideBar/Sections/Extensions/index.tsx
""""""
import { sketchs } from 'src/assets/sketchMetadata' // <--- UPDATED IMPORT PATH
import Text from 'src/components/Core/Text'
import { Container } from './styled'
import Image from 'next/image'
import { useState, useEffect } from 'react'
import dynamic from 'next/dynamic'

// Dynamically import AnimationOverlay, disable SSR
const DynamicAnimationOverlay = dynamic(
  () => import('src/components/Core/AnimationOverlay'),
  { ssr: false }
)

const Extensions: React.FC = () => {
  const [activeSketch, setActiveSketch] = useState<string | null>(null)

  useEffect(() => {
    console.log('[Extensions] Checking sketchs value on mount:', sketchs)
  }, [])

  const handleSketchClick = (name: string) => {
    console.log(`[Extensions] handleSketchClick called with: ${name}`)
    console.log('[Extensions] Checking sketchs value on click:', sketchs)
    if (!Array.isArray(sketchs)) {
      console.error('[Extensions] sketchs is not an array on click!')
      return
    }
    console.log(`[Extensions] Setting state: activeSketch=${name}`)
    setActiveSketch(name)
  }

  useEffect(() => {
    console.log(
      `[Extensions] activeSketch state confirmed updated to: ${activeSketch}`
    )
  }, [activeSketch])

  if (!Array.isArray(sketchs)) {
    console.warn(
      '[Extensions] sketchs array not available during render, rendering empty div.'
    )
    return <div>Loading extensions...</div>
  }

  return (
    <>
      <div>
        {sketchs.map(sketch => (
          <Container
            key={sketch.name}
            onClick={() => handleSketchClick(sketch.name)}
          >
            <div>
              <Image
                width={50}
                height={50}
                src={sketch.icon ? sketch.icon : '/icons/linear.png'}
                alt={`${sketch.name} icon`}
              />
            </div>

            <div>
              <Text weight="bold">{sketch.name}</Text>
              <Text size={12}>{sketch.description}</Text>
            </div>
          </Container>
        ))}
      </div>
      {activeSketch && (
        <DynamicAnimationOverlay
          key={activeSketch}
          sketchName={activeSketch}
          onClose={() => {
            console.log(`[Extensions] Closing overlay for: ${activeSketch}`)
            setActiveSketch(null)
          }}
        />
      )}
    </>
  )
}

export default Extensions
""""""


File: src/components/Home/SideBar/Sections/Extensions/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  padding: 8px;
  display: grid;
  grid-template-columns: 50px 1fr;
  grid-gap: 20px;
  justify-content: end;
  box-sizing: border-box;
  cursor: pointer;
  max-width: 100%;
  :hover {
    background-color: ${({ theme }) => theme.colors.sideHighlight};
  }
`
""""""


File: src/components/Home/SideBar/Sections/Files/RenderDir/index.tsx
""""""
import { useState } from 'react'
import useContextFileView from 'src/hooks/useContextFileView'
import { RealContainer, Container, Children, File } from './styled'
import FileTile from 'src/components/Core/TileFile'
import { FileType } from 'src/contexts/FileContext'
import useContextFile from 'src/hooks/useContextFile'
import useContextSidebar from 'src/hooks/useSideBar'

export type RenderDirectoryProps = {
  files: FileType[]
  embedded: number
}

const RenderDirectory: React.FC<RenderDirectoryProps> = ({
  files,
  embedded = 0
}) => {
  const resumeName = process.env.RESUME || 'resume'
  const { focusedFileView, focusedFile } = useContextFile()
  const { openFile } = useContextFileView()
  const { setOpen: setSideBarOpen } = useContextSidebar()
  const openState = Object.fromEntries(
    files.map(({ path }) => [[path], path === resumeName])
  )
  const [open, setOpen] = useState(openState)
  const handleClick = (file: FileType) => {
    const isFile = !file?.children?.length

    if (isFile) {
      openFile(file.path, focusedFileView)
      setSideBarOpen(false)
    }

    setOpen((prevOpen: { [key: string]: boolean }) => ({
      ...prevOpen,
      [file?.path]: !prevOpen[file?.path]
    }))
  }

  return (
    <RealContainer embedded={embedded}>
      {!!files.length &&
        files.map(file => (
          <Container
            embedded={embedded}
            isHighLighted={file?.name === focusedFile}
            key={file.path}
          >
            <File embedded={embedded}>
              <div onClick={() => handleClick(file)}>
                <FileTile
                  folder={!!file?.children?.length}
                  open={open[file?.path]}
                  filePath={file.path}
                />
              </div>
            </File>
            <Children embedded={embedded} opened={open[file?.path]}>
              {file?.children && (
                <RenderDirectory
                  embedded={embedded + 1}
                  files={file?.children}
                />
              )}
            </Children>
          </Container>
        ))}
    </RealContainer>
  )
}

export default RenderDirectory
""""""


File: src/components/Home/SideBar/Sections/Files/RenderDir/styled.ts
""""""
import styled from 'styled-components'

interface FileProps {
  isHighLighted?: boolean
  embedded: number
}
interface ChildrenProps {
  opened: boolean
  embedded: number
}
interface ContainerProps {
  embedded: number
  isHighLighted: boolean
}

export const Container = styled.div<ContainerProps>`
  background-color: ${({ isHighLighted, theme }) =>
    isHighLighted && theme.colors.sideHighlight};
  :hover {
    background-color: ${({ isHighLighted, theme }) =>
      isHighLighted
        ? theme.colors.sideHighlight
        : theme.colors.sideHighlightHover};
  }
`

export const RealContainer = styled.div<FileProps>`
  position: relative;
  cursor: pointer;
  :hover {
    :before {
      content: ' ';
      left: ${({ embedded }) => `${embedded * 8 + 4}px`};
      position: absolute;
      height: 100%;
      border-left: ${({ embedded, theme }) =>
        embedded && `1px solid ${theme.colors.fileLine}`};
      z-index: 9999;
    }
  }
`

export const File = styled.div<FileProps>`
  padding-left: ${({ embedded }) => embedded && `${embedded * 8}px`};
`

export const Children = styled.div<ChildrenProps>`
  display: ${({ opened }) => (opened ? 'grid' : 'none')};
  background-color: ${({ theme }) => theme.colors.menuBackground};
`
""""""


File: src/components/Home/SideBar/Sections/Files/index.tsx
""""""
import useContextFile from 'src/hooks/useContextFile'
import RenderDir from './RenderDir'
import Text from 'src/components/Core/Text'
import { Container, Title } from './styled'
const Files: React.FC = () => {
  const { treeFiles } = useContextFile()

  return (
    treeFiles && (
      <Container>
        <Title>
          <Text size={12}>EXPLORER</Text>
        </Title>

        <RenderDir embedded={0} files={treeFiles} />
      </Container>
    )
  )
}

export default Files
""""""


File: src/components/Home/SideBar/Sections/Files/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  overflow: auto;
  height: 100%;
  box-sizing: border-box;
`

export const Title = styled.div`
  padding: 4px 8px;
`
""""""


File: src/components/Home/SideBar/Sections/Profile/index.tsx
""""""
const Profile: React.FC = () => {
  return <div>Profile!</div>
}

export default Profile
""""""


File: src/components/Home/SideBar/Sections/Search/FileMatch/FormattedLabel/index.tsx
""""""
import { Highlight, Span } from './styled'

interface FormattedLabelProps {
  label: string
  value: string
}

const FormattedLabel: React.FC<FormattedLabelProps> = ({ label, value }) => {
  if (!value) {
    return <> </>
  }
  const splittedString = label && value ? label?.split(value) : ['']

  const splittedLabel = splittedString.map((s, i) => (
    <span key={s + i}>{s}</span>
  ))
  return (
    <Span as="span">
      {splittedLabel.reduce<JSX.Element | JSX.Element[]>((prev, current, i) => {
        if (!i) {
          return [current]
        }
        return (
          <span>
            {prev}
            <Highlight as="span" key={value + current}>
              {value}
            </Highlight>
            {current}
          </span>
        )
      }, <span />)}
    </Span>
  )
}

export default FormattedLabel
""""""


File: src/components/Home/SideBar/Sections/Search/FileMatch/FormattedLabel/styled.ts
""""""
import styled from 'styled-components'
import Text from 'src/components/Core/Text'

export const Highlight = styled(Text)`
  background-color: ${({ theme }) => theme.colors.queryString};
`

export const Span = styled(Text)`
  white-space: nowrap;
  min-width: 0;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  font-family: sans-serif;
`
""""""


File: src/components/Home/SideBar/Sections/Search/FileMatch/index.tsx
""""""
import { MatchHeader, Match, Container, MatchBody, ArrowIcon } from './styled'
import Text from 'src/components/Core/Text'
import FileTile from 'src/components/Core/TileFile'
import FormattedLabel from './FormattedLabel'
import { useState } from 'react'
import useContextFileView from 'src/hooks/useContextFileView'
import useContextFile from 'src/hooks/useContextFile'
export type FileMatchProps = {
  path: string
  query: string
  lines: string[] | string | undefined
  file: string
  i: number
}

const FileMatch: React.FC<FileMatchProps> = ({
  path,
  lines,
  file,
  i,
  query
}) => {
  const { focusedFileView } = useContextFile()
  const { openFile } = useContextFileView()
  const [open, setOpen] = useState(true)
  return (
    <Container>
      <MatchHeader
        onClick={() => {
          setOpen(!open)
        }}
      >
        <div>
          <ArrowIcon open={open} />
        </div>
        <FileTile folder={false} open={false} filePath={file} />
        <Text as="pre" color="subString" size={13}>
          {path}
        </Text>
      </MatchHeader>
      <MatchBody onClick={() => openFile(file, focusedFileView)}>
        {open &&
          lines?.length &&
          typeof lines !== 'string' &&
          lines.map((line, j) => (
            <Match key={i + j}>
              <Text size={12}>
                <FormattedLabel label={line} value={query} />
              </Text>
            </Match>
          ))}
      </MatchBody>
    </Container>
  )
}

export default FileMatch
""""""


File: src/components/Home/SideBar/Sections/Search/FileMatch/styled.ts
""""""
import styled from 'styled-components'
import Arrow from 'public/icons/arrow.svg'

export const Container = styled.div`
  cursor: pointer;
  max-width: 100%;
`
export const Match = styled.div`
  padding: 3px;
  padding-left: 20px;
  box-sizing: border-box;
  :hover {
    background-color: ${({ theme }) => theme.colors.sideHighlightHover};
  }
`
export const MatchBody = styled.div``
export const MatchHeader = styled.div`
  display: flex;
  box-sizing: border-box;
  pre {
    font-family: sans-serif;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  svg {
    width: 10px;
    height: 10px;
  }
  :hover {
    background-color: ${({ theme }) => theme.colors.sideHighlightHover};
  }
`

export const ArrowIcon = styled(Arrow)`
  transform: ${({ open }) => !open && 'rotate(-90deg)'};
  fill: ${({ theme }) => theme.colors.text};
`
""""""


File: src/components/Home/SideBar/Sections/Search/index.tsx
""""""
import { useState } from 'react'
import Text from 'src/components/Core/Text'
import InputText from 'src/components/Core/InputText'
import useContextFile from 'src/hooks/useContextFile'
import FileMatch from './FileMatch'

import {
  InputContainer,
  CaseSensitiveContainer,
  Container,
  Title,
  Form
} from './styled'
import CaseSensitive from 'public/icons/case-sensitive.svg'
import Replace from 'public/icons/replace.svg'

const Search: React.FC = () => {
  const { files, setFiles } = useContextFile()
  const [query, setQuery] = useState('')
  const [replacer, setReplacer] = useState('')
  const [caseInsensitive, setCaseInsensitive] = useState(false)

  const filesThatContainSearch = !caseInsensitive
    ? files.filter(({ newContent }) => newContent?.includes(query))
    : files
        .filter(({ newContent }) =>
          newContent?.toLowerCase().includes(query.toLowerCase())
        )
        .map(file => ({
          ...file,
          newContent: file?.newContent?.toLocaleLowerCase(),
          content: file?.content?.toLocaleLowerCase()
        }))

  const matches =
    (query &&
      filesThatContainSearch &&
      filesThatContainSearch.map(file => {
        const lines = file?.newContent?.includes(query)
          ? file?.newContent
          : file?.content
        const lineContentContainQuery =
          lines &&
          lines
            .split(/\r?\n/)
            .filter(line =>
              line?.toLocaleLowerCase().includes(query.toLowerCase())
            )

        return {
          path: file?.path,
          name: file?.name,
          lines: lineContentContainQuery,
          file
        }
      })) ||
    []

  const totalFilesMatched = matches.length
  let totalLinesMatched = 0

  matches?.forEach(match => {
    if (match && match?.lines) totalLinesMatched += match?.lines?.length
  })

  const replace = (): void => {
    const newFiles = files.map(file => {
      const { path } = file
      const queryRegex = new RegExp(query, `g${caseInsensitive ? 'i' : ''}`)
      const newContent = file?.newContent?.replace(queryRegex, replacer)

      return { ...file, path, newContent }
    })
    setFiles(newFiles)
  }

  return (
    <Container>
      <Title>
        <Text size={12}>SEARCH</Text>
      </Title>
      <Form>
        <InputContainer>
          <InputText
            onChange={e => setQuery(e?.target?.value)}
            value={query}
            id="query"
            name="query"
          ></InputText>
          <CaseSensitiveContainer
            caseInsensitive={caseInsensitive}
            onClick={() => setCaseInsensitive(!caseInsensitive)}
          >
            <CaseSensitive />
          </CaseSensitiveContainer>
        </InputContainer>
        <InputContainer>
          <InputText
            onChange={e => setReplacer(e?.target?.value)}
            value={replacer}
            id="replacer"
            name="replacer"
          ></InputText>
          <CaseSensitiveContainer onClick={() => replace()}>
            <Replace />
          </CaseSensitiveContainer>
        </InputContainer>
      </Form>

      <>
        <Text>
          {totalLinesMatched > 0
            ? ` ${totalLinesMatched} results in ${totalFilesMatched} files`
            : ''}
        </Text>
        {matches &&
          matches?.map(({ path, lines, file }, i) => (
            <FileMatch
              query={query}
              path={path}
              lines={lines}
              file={file.path}
              i={i}
              key={path + i}
            ></FileMatch>
          ))}
      </>
    </Container>
  )
}

export default Search
""""""


File: src/components/Home/SideBar/Sections/Search/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  padding: 6px;
  box-sizing: border-box;
  overflow-x: hidden;
  overflow-y: auto;
  max-height: 100%;
  padding-bottom: 36px;
`

export const InputContainer = styled.div`
  background-color: ${({ theme }) => theme.colors.inputBackground};
  display: grid;
  grid-template-columns: 1fr max-content;
  padding: 3px;
  max-width: 100%;
  input {
    min-width: 0px;
  }
`

export const Title = styled.div`
  padding: 4px 0px;
`

export const Form = styled.div`
  display: grid;
  grid-gap: 1em;
  padding: 8px;
`

interface PropsCaseSensitiveContainer {
  caseInsensitive?: boolean
}

export const CaseSensitiveContainer = styled.div<PropsCaseSensitiveContainer>`
  cursor: pointer;
  background-color: ${({ theme, caseInsensitive }) =>
    !caseInsensitive
      ? theme.colors.inputBackground
      : theme.colors.selectedBlue};
  display: flex;
  padding: 3px;
`
""""""


File: src/components/Home/SideBar/Sections/Settings/index.tsx
""""""
const Settings: React.FC = () => {
  return <div>Settings!</div>
}

export default Settings
""""""


File: src/components/Home/SideBar/Sections/Source/RenderDir/index.tsx
""""""
import { useState } from 'react'
import { RealContainer, Container, Children, File } from './styled'
import FileTile from 'src/components/Core/TileFile'
import { FileType } from 'src/contexts/FileContext'
import useContextFileView from 'src/hooks/useContextFileView'
import useContextFile from 'src/hooks/useContextFile'

export type RenderDirectoryProps = {
  files: FileType[]
  embedded: number
}

const RenderDirectory: React.FC<RenderDirectoryProps> = ({
  files,
  embedded = 0
}) => {
  const { currentFile, openFile } = useContextFileView()
  const { focusedFileView } = useContextFile()
  const openState = Object.fromEntries(files.map(({ path }) => [[path], true]))

  const [open, setOpen] = useState(openState)

  const handleClick = (file: FileType) => {
    const isFile = !file?.children?.length

    if (isFile) {
      openFile(file.path, focusedFileView)
    }

    setOpen((prevOpen: { [key: string]: boolean }) => ({
      ...prevOpen,
      [file?.path]: !prevOpen[file?.path]
    }))
  }
  return (
    <RealContainer embedded={embedded}>
      {!!files.length &&
        files.map(file => (
          <Container
            embedded={embedded}
            isHighLighted={file?.path === currentFile}
            key={file.path}
          >
            <File
              embedded={embedded}
              isHighLighted={file?.path === currentFile}
            >
              <div onClick={() => handleClick(file)}>
                <FileTile
                  folder={!!file?.children?.length}
                  open={open[file?.path]}
                  filePath={file?.path}
                />
              </div>
            </File>
            <Children embedded={embedded} opened={open[file?.path]}>
              {file?.children && (
                <RenderDirectory
                  embedded={embedded + 1}
                  files={file?.children}
                />
              )}
            </Children>
          </Container>
        ))}
    </RealContainer>
  )
}

export default RenderDirectory
""""""


File: src/components/Home/SideBar/Sections/Source/RenderDir/styled.ts
""""""
import styled from 'styled-components'

interface FileProps {
  isHighLighted?: boolean
  embedded: number
}
interface ChildrenProps {
  opened: boolean
  embedded: number
}
interface ContainerProps {
  embedded: number
  isHighLighted: boolean
}

export const Container = styled.div<ContainerProps>`
  background-color: ${({ isHighLighted, theme }) =>
    isHighLighted && theme.colors.sideHighlight};
  :hover {
    background-color: ${({ isHighLighted, theme }) =>
      isHighLighted
        ? theme.colors.sideHighlight
        : theme.colors.sideHighlightHover};
  }
`

export const RealContainer = styled.div<FileProps>`
  position: relative;
  cursor: pointer;
  :hover {
    :before {
      content: ' ';
      left: ${({ embedded }) => `${embedded * 8 + 4}px`};
      position: absolute;
      height: 100%;
      border-left: ${({ embedded, theme }) =>
        embedded && `1px solid ${theme.colors.fileLine}`};
      z-index: 9999;
    }
  }
`

export const File = styled.div<FileProps>`
  padding-left: ${({ embedded }) => embedded && `${embedded * 8}px`};
`

export const Children = styled.div<ChildrenProps>`
  display: ${({ opened }) => (opened ? 'grid' : 'none')};
  background-color: ${({ theme }) => theme.colors.menuBackground};
`
""""""


File: src/components/Home/SideBar/Sections/Source/index.tsx
""""""
import useContextFile from 'src/hooks/useContextFile'
import RenderDir from './RenderDir'
import Text from 'src/components/Core/Text'

import List from 'public/icons/list.svg'
import Tree from 'public/icons/tree.svg'

import {
  Container,
  Title,
  Row,
  RowClickable,
  IconContainer,
  Ballon,
  ArrowIcon
} from './styled'
import { useTree } from 'src/hooks/useTree'

import { FileType } from 'src/contexts/FileContext'
import { useState } from 'react'

const Files: React.FC = () => {
  const { build, rebuildPaths } = useTree()
  const { diffFiles } = useContextFile()

  const [type, setType] = useState<'tree' | 'list'>('list')
  const [open, setOpen] = useState<boolean>(true)

  const repo = process.env.REPO || 'luisguilher.me'
  const splittedDiffFiles = rebuildPaths(diffFiles)
  const absoluteDiffTree = build(splittedDiffFiles)

  const resumeFiles = absoluteDiffTree.filter(({ path }) => path === 'resume')
  const repoFiles = absoluteDiffTree.filter(({ path }) => path !== 'resume')

  const relativeDiffTree: FileType[] = repoFiles.length
    ? [{ path: repo, name: repo, children: repoFiles }, ...resumeFiles]
    : [...resumeFiles]

  const sourceFiles = type === 'tree' ? relativeDiffTree : diffFiles
  const totalChanges = JSON.stringify(diffFiles.length || 0)

  const toggleTypeList = () => {
    setType(type === 'list' ? 'tree' : 'list')
  }

  return (
    sourceFiles && (
      <Container>
        <Row>
          <Title>
            <Text size={12}>SOURCE CONTROL</Text>
          </Title>
          <IconContainer onClick={toggleTypeList}>
            {type === 'list' ? <Tree /> : <List />}
          </IconContainer>
        </Row>
        <RowClickable onClick={() => setOpen(!open)}>
          <Row>
            <ArrowIcon height="10px" width="10px" open={open} />
            <Text size={12}>Changes </Text>
          </Row>
          <Ballon>
            <Text size={12}>{totalChanges} </Text>
          </Ballon>
        </RowClickable>
        {open && <RenderDir embedded={0} files={sourceFiles} />}
      </Container>
    )
  )
}

export default Files
""""""


File: src/components/Home/SideBar/Sections/Source/styled.ts
""""""
import styled from 'styled-components'
import Arrow from 'public/icons/arrow.svg'

export const Container = styled.div`
  overflow: auto;
  height: 100%;
  box-sizing: border-box;
`

export const Title = styled.div`
  padding: 4px 8px;
`
export const Ballon = styled.div`
  background-color: ${({ theme }) => theme.colors.selectedNavigationFile};
  padding: 4px 8px;
  border-radius: 50%;
`

export const IconContainer = styled.div`
  padding: 4px 8px;
  cursor: pointer;
`

export const RowClickable = styled.div`
  display: flex;
  justify-content: space-between;
  cursor: pointer;
`

export const Row = styled.div`
  display: flex;
  justify-content: space-between;
`

export const ArrowIcon = styled(Arrow)`
  transform: ${({ open }) => !open && 'rotate(-90deg)'};
  fill: ${({ theme }) => theme.colors.text};
  margin: 3px;
`
""""""


File: src/components/Home/SideBar/index.tsx
""""""
import { Container, Main, ModalContent } from './styled'
import Files from './Sections/Files'
import Search from './Sections/Search'
import Source from './Sections/Source'
import Extensions from './Sections/Extensions'

import NavBar from './NavBar'
import useWindowSize from 'src/hooks/useWindow'
import Modal from 'src/components/Core/Modal'
import useSideBar from 'src/hooks/useSideBar'

type SelectedSectionType =
  | 'files'
  | 'search'
  | 'source'
  | 'debug'
  | 'extensions'

const SideBar: React.FC = () => {
  const { open, setOpen, selectedSection } = useSideBar()
  const { isMedium } = useWindowSize()

  const sections: {
    [name in SelectedSectionType]: {
      component?: React.FC | undefined
      onClick?: () => void
    }
  } = {
    files: { component: Files }, // NOTE : Core/Editor
    source: { component: Source }, // NOTE : Releases/Features/Commits
    debug: {}, // NOTE :  Play the sketchs
    extensions: { component: Extensions },
    search: { component: Search } // NOTE : Search on downloaded files
  }

  const Section =
    selectedSection !== 'profile' &&
    selectedSection !== 'settings' &&
    sections[selectedSection].component

  return (
    <Container>
      <NavBar />

      {!isMedium && Section ? (
        <Main>
          <Section />
        </Main>
      ) : (
        Section && (
          <Modal setClose={() => setOpen(false)} open={open}>
            <ModalContent onClick={e => e.stopPropagation()}>
              <Section />
            </ModalContent>
          </Modal>
        )
      )}
    </Container>
  )
}

export default SideBar
""""""


File: src/components/Home/SideBar/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  display: grid;
  grid-template-columns: max-content 1fr;
  background-color: ${({ theme }) => theme.colors.menuBackground};
  height: 100%;
  max-height: calc(100vh);
  box-sizing: border-box;
  z-index: 99;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
`

export const ModalContent = styled.div`
  position: fixed;
  background-color: ${({ theme }) => theme.colors.menuBackground};
  width: max-content;
  min-width: 150px;
  width: 100%;
  max-width: calc(100vw - 52px);
  left: 52px;
  box-sizing: border-box;
  overflow: hidden;
  height: calc(100%);
  padding-bottom: 36px;
`

export const Main = styled.div`
  height: calc(100% - 10px);
  box-sizing: border-box;
  resize: horizontal;
  overflow: hidden;
  width: 300px;
  min-width: 300px;
  position: relative;

  background-color: ${({ theme }) => theme.colors.menuBackground};

  ::after {
    content: ' ';
    position: absolute;
    bottom: 5px;
    right: 5px;
    height: 16px;
    width: 16px;
    background-position: center;
    background-repeat: no-repeat;
    background-size: contain;
    background-image: url('/icons/arrow-both.svg');
  }
`
""""""


File: src/components/Home/TopBar/index.tsx
""""""
import { Container } from './styled'
import Text from 'src/components/Core/Text'
import Image from 'next/image'
import { useWindowSize } from 'src/hooks/useWindow'
const TopBar: React.FC = () => {
  const { isMedium } = useWindowSize()
  return (
    <Container>
      <Image height="20" width="20" src="/favicon.png" />
      <Text size={13}>luisguilher.me - Visual Profile Code</Text>
      {!isMedium && <Text size={13}>Luís Guilherme Pelin Martins</Text>}
    </Container>
  )
}

export default TopBar
""""""


File: src/components/Home/TopBar/styled.ts
""""""
import styled from 'styled-components'

export const Container = styled.div`
  background-color: ${({ theme }) => theme.colors.topBarBackground};
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0px 20px;
  z-index: 9999;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
`
""""""


File: src/components/Home/index.tsx
""""""
import SideBar from './SideBar'
import TopBar from './TopBar'
import { Container, Content } from './styled'
import Footer from './Footer'
import FileViewComponent from './FileViewComponent'
import useFileViewsContext from 'src/hooks/useContextFileView'
import useContextPrint from 'src/hooks/useContextPrint'
import { useState, useEffect } from 'react' // Import hooks

const Home: React.FC = () => {
  const { getRootId } = useFileViewsContext()
  const rootId = getRootId()
  const { Printable } = useContextPrint()
  const [isClient, setIsClient] = useState(false) // State to track client-side mount

  useEffect(() => {
    setIsClient(true) // Set to true once component mounts on the client
  }, [])

  return (
    <>
      <Printable />
      <Container>
        <TopBar />
        <Content>
          <SideBar />
          {/* Only render FileViewComponent on the client */}
          {isClient && <FileViewComponent id={rootId} />}
        </Content>
        <Footer />
      </Container>
    </>
  )
}

export default Home
""""""


File: src/components/Home/styled.ts
""""""
import styled from 'styled-components'

export const Content = styled.div`
  display: flex;
  height: 100%;
  box-sizing: border-box;
`
export const Container = styled.div`
  display: grid;
  box-sizing: border-box;
  grid-template-rows: 22px 1fr;
  background: ${({ theme }) => theme.colors.editorBackground};
  max-height: 100vh;
  height: 100vh;
  @media print {
    display: none;
  }
`

export const FileContainer = styled.div`
  position: relative;
`

export const Main = styled.div`
  display: grid;
  grid-template-rows: min-content 1fr;
  width: 100%;
  height: 100%;
  max-height: 100%;
  box-sizing: border-box;
`
""""""


File: src/components/README.md
""""""

This directory contains all the React components used in the application.

## Structure

Components are organized into two main subdirectories:

-   **`Core/`**: Contains highly reusable, generic components that form the building blocks of the UI and application logic. These components are designed to be independent of specific application features. See the [Core Components README](./Core/README.md) for more details.
-   **`Home/`**: Contains components specifically related to the main "IDE" layout and features of the `luisguilher.me` page. These components often orchestrate multiple `Core` components and interact heavily with the application's contexts and state. Examples include `SideBar`, `FileView`, `TopBar`, `Footer`, etc.

## Naming Conventions

-   Component directories are typically named using PascalCase (e.g., `FileView`).
-   The main component file within a directory is usually `index.tsx`.
-   Styled components specific to a component are often placed in `styled.ts`.

## Related READMEs

-   [Core Components README](./Core/README.md)
-   [Root README](../../README.md)
""""""


File: src/contexts/FileContext.tsx
""""""
import { createContext, useState, useEffect, useReducer, Dispatch } from 'react'
import { getResumeData } from './getResumeFiles'
import useTree from 'src/hooks/useTree'
import fileReducer, {
  FileType as FileT,
  ActionType
} from 'src/reducers/FileReducer'
import githubService from 'src/services/github'

export type FileType = FileT

export type FileContextType = {
  files: FileType[]
  treeFiles: FileType[]
  diffFiles: FileType[]
  setFiles: (files: FileType[]) => void
  setContent: (file: FileType, content: string) => void
  setImage: (file: FileType, content: JSX.Element | undefined) => void
  setNewContent: (file: FileType, content: string) => void
  focusedFile: string | null
  setFocusedFile: (file: string | null) => void
  findTreeFile: (path: string) => FileType | null
  focusedFileView: number
  setFocusedFileView: (file: number) => void
}

export const FileContext = createContext({} as FileContextType)

export const FileProvider: React.FC = ({ children }) => {
  const repoName = process.env.REPO || 'luisguilher.me'
  const { build, flatTree } = useTree()
  const [tree, setTree] = useState<FileType[]>([])
  const resumeFiles = getResumeData()

  const [treeFiles, setTreeFiles] = useState<FileType[]>([
    {
      path: 'resume',
      name: 'resume',
      children: resumeFiles
    },
    { path: repoName, name: repoName, children: [] }
  ])

  const initialFiles = flatTree(treeFiles)
  const initialDiffFiles: FileType[] = initialFiles.map(file => ({
    ...file,
    isDiff: true,
    path: file?.path.concat('__working__tree__')
  }))
  const initialState = initialFiles.concat(initialDiffFiles)
  const [files, dispatch]: [files: FileType[], dispatch: Dispatch<ActionType>] =
    useReducer(fileReducer, initialState)

  const setImage = (selectedFile: FileType, image: JSX.Element | undefined) => {
    dispatch({ type: 'SET_IMAGE', payload: { ...selectedFile, image } })
  }

  const setContent = (selectedFile: FileType, content: string) => {
    dispatch({ type: 'SET_CONTENT', payload: { ...selectedFile, content } })
  }

  const setNewContent = (selectedFile: FileType, newContent: string) => {
    dispatch({
      type: 'SET_NEW_CONTENT',
      payload: { ...selectedFile, newContent }
    })
  }

  const setFiles = (files: FileType[]) => {
    dispatch({ type: 'SET_FILES', payload: files })
  }

  const findTreeFile = (path: string, files: FileType[]): FileType | null => {
    for (const file of files) {
      if (file.path === path) {
        return file
      }
      if (file.children) {
        const found = findTreeFile(path, file.children)
        if (found) {
          return found
        }
      }
    }
    return null
  }

  const diffFiles = files.filter(({ isDiff, diff }) => isDiff && diff)

  useEffect(() => {
    if (tree) {
      const newTreeFiles = treeFiles.map(file => ({
        ...file,
        children: file.path === repoName ? tree : file?.children
      }))

      const newFiles: FileType[] = flatTree(newTreeFiles)
      const newDiffFiles: FileType[] = newFiles.map(file => ({
        ...file,
        isDiff: true,
        path: file?.path.concat('__working__tree__')
      }))

      setTreeFiles(newTreeFiles)
      setFiles(newFiles.concat(newDiffFiles))
    }
  }, [tree])

  useEffect(() => {
    const fetchTree = async () => {
      const rawTree = await githubService.fetchRepoTree()
      const newTree = build(rawTree)
      setTree(newTree)
    }

    fetchTree()
  }, [])

  const [focusedFile, setFocusedFile] = useState<string | null>(
    'resume/complete-resume.yml'
  )
  const [focusedFileView, setFocusedFileView] = useState<number>(0)

  return (
    <FileContext.Provider
      value={{
        files,
        setFiles,
        treeFiles,
        setContent,
        setImage,
        setNewContent,
        diffFiles,
        focusedFile,
        setFocusedFile,
        findTreeFile: (path: string) => findTreeFile(path, treeFiles),
        focusedFileView,
        setFocusedFileView
      }}
    >
      {children}
    </FileContext.Provider>
  )
}
""""""


File: src/contexts/FileViewContext.tsx
""""""
import { createContext, useEffect, useState } from 'react'

export type Orientation = 'top' | 'bottom' | 'right' | 'left'

export type FileViewsContextType = {
  openedFiles: string[]
  currentFile: string | undefined
  orientation: Orientation
  fileViewsTree: FileViewsContextType
  id: number
  children: FileViewsContextType[]
  openFile: (fileId: string, nodeId: number) => void
  closeFile: (fileId: string, nodeId: number) => void
  setCurrentFile: (fileId: string, nodeId: number) => void
  findNodeById: (
    id: number,
    node: FileViewsContextType
  ) => FileViewsContextType | null
  createChild: (
    fileId: string,
    orientation: Orientation,
    parentId: number
  ) => void
  removeNode: (nodeId: number) => void
  getRootId: () => number
  setOrientation: (orientation: Orientation, nodeId: number) => void
}

export const FileViewsContext = createContext<FileViewsContextType>(
  {} as FileViewsContextType
)

const noop = () => {
  // no op;
}

export const FileViewsProvider: React.FC<{ initialOpenedFile?: string }> = ({
  children,
  initialOpenedFile
}) => {
  const isGuiding =
    typeof window !== 'undefined' &&
    JSON.parse(localStorage?.getItem('GUIDE_TOUR') ?? 'false')

  const [fileViewsTree, setFileViewsTree] = useState<FileViewsContextType>({
    openedFiles: initialOpenedFile && !isGuiding ? [initialOpenedFile] : [],
    currentFile: !isGuiding ? initialOpenedFile : undefined,
    orientation: 'bottom',
    id: 0,
    children: [],
    openFile: noop,
    closeFile: noop,
    setCurrentFile: noop,
    findNodeById: () => null,
    getRootId: () => 0,
    createChild: noop,
    removeNode: noop,
    setOrientation: noop,
    fileViewsTree: {} as FileViewsContextType
  })

  const getRootId = () => fileViewsTree.id

  const setOrientation = (orientation: Orientation, nodeId: number) => {
    setFileViewsTree(prevTree => {
      const nodeToUpdate = findNodeById(nodeId, prevTree)
      if (nodeToUpdate) {
        nodeToUpdate.orientation = orientation
      }
      return { ...prevTree }
    })
  }

  const setCurrentFile = (fileId: string, nodeId: number) => {
    setFileViewsTree(prevTree => {
      const nodeToUpdate = findNodeById(nodeId, prevTree)
      if (nodeToUpdate) {
        nodeToUpdate.currentFile = fileId
        nodeToUpdate.openedFiles = [
          ...new Set([...nodeToUpdate.openedFiles, fileId])
        ]
      }
      return { ...prevTree }
    })
  }

  const openFile = (fileId: string, nodeId: number) => {
    setFileViewsTree(prevTree => {
      const nodeToUpdate = findNodeById(nodeId, prevTree)
      if (nodeToUpdate) {
        if (!nodeToUpdate.openedFiles.includes(fileId)) {
          nodeToUpdate.openedFiles.push(fileId)
        }
        nodeToUpdate.currentFile = fileId
      }
      return { ...prevTree }
    })
  }

  const closeFile = (fileId: string, nodeId: number) => {
    setFileViewsTree(prevTree => {
      const nodeToUpdate = findNodeById(nodeId, prevTree)
      if (nodeToUpdate) {
        const newOpenedFiles = nodeToUpdate.openedFiles.filter(
          id => id !== fileId
        )
        nodeToUpdate.openedFiles = newOpenedFiles
        if (nodeToUpdate.currentFile === fileId) {
          nodeToUpdate.currentFile =
            nodeToUpdate.openedFiles[nodeToUpdate.openedFiles.length - 1] ||
            undefined
        }
      }
      return { ...prevTree }
    })
  }

  const findNodeById = (
    id: number,
    node: FileViewsContextType
  ): FileViewsContextType | null => {
    if (node.id === id) return node
    for (const child of node.children) {
      const found = findNodeById(id, child)
      if (found) return found
    }
    return null
  }

  const getParentNode = (
    nodeId: number,
    node: FileViewsContextType,
    parent: FileViewsContextType | null = null
  ): FileViewsContextType | null => {
    if (node.id === nodeId) {
      return parent
    }
    for (const child of node.children) {
      const result = getParentNode(nodeId, child, node)
      if (result) {
        return result
      }
    }
    return null
  }

  const removeNode = (nodeId: number) => {
    const targetNode = findNodeById(nodeId, fileViewsTree)
    const parentNode = getParentNode(nodeId, fileViewsTree)
    const currentChildrenToRecover = targetNode?.children ?? []

    setFileViewsTree(prevTree => {
      if (prevTree.id === nodeId) return prevTree
      if (parentNode) {
        parentNode.children = parentNode.children.filter(
          child => child.id !== nodeId
        )
        parentNode.children.push(...currentChildrenToRecover)
      }
      return { ...prevTree }
    })
  }

  const addNewNode = (
    node: FileViewsContextType,
    newChild: FileViewsContextType
  ) => {
    if (node.children.length === 0) {
      node.children.push(newChild)
    } else {
      // Creating an intermediary node
      const intermediaryNode: FileViewsContextType = {
        ...node.children[0],
        id: node.children[node.children.length - 1].id + 1,
        children: [newChild]
      }
      node.children = [intermediaryNode]
    }
  }

  const flattenTree = (node: FileViewsContextType): FileViewsContextType[] => {
    const flatList: FileViewsContextType[] = []

    const traverse = (node: FileViewsContextType) => {
      flatList.push({ ...node, children: [] })
      node.children.forEach(child => traverse(child))
    }

    traverse(node)
    return flatList
  }

  const rebuildTree = (nodes: FileViewsContextType[]): FileViewsContextType => {
    if (nodes.length === 0) {
      return {
        openedFiles: [],
        currentFile: undefined,
        orientation: 'bottom',
        id: 0,
        children: [],
        openFile: noop,
        closeFile: noop,
        setCurrentFile: noop,
        findNodeById: () => null,
        getRootId: () => 0,
        createChild: noop,
        removeNode: noop,
        setOrientation: noop,
        fileViewsTree: {} as FileViewsContextType
      }
    }

    const root = {
      ...nodes,
      ...nodes[0],
      id: 0,
      children: [] as FileViewsContextType[]
    }

    let currentNode = root

    for (let i = 1; i < nodes.length; i++) {
      const newNode = {
        ...nodes,
        ...nodes[i],
        children: []
      }

      currentNode.children = [newNode]
      currentNode = newNode
    }

    return root
  }

  const rebalanceTree = (node: FileViewsContextType): FileViewsContextType => {
    // Flatten the tree
    let nodes = flattenTree(node)
    // Filter out nodes without openedFiles
    nodes = nodes.filter(n => n.openedFiles.length > 0)
    return rebuildTree(nodes)
  }

  useEffect(() => {
    const newRebalancedTree = rebalanceTree(fileViewsTree)

    const haveTreeViewsChanged =
      flattenTree(newRebalancedTree).length !==
      flattenTree(fileViewsTree).length

    haveTreeViewsChanged && setFileViewsTree(newRebalancedTree)
  }, [fileViewsTree])

  const createChild = (
    fileId: string,
    orientation: Orientation,
    parentId = 0
  ) => {
    setFileViewsTree(prevTree => {
      const newChild: FileViewsContextType = {
        openedFiles: [fileId],
        currentFile: fileId,
        orientation: orientation,
        id: Date.now(),
        children: [],
        fileViewsTree,
        setCurrentFile,
        openFile,
        closeFile,
        createChild,
        findNodeById,
        removeNode,
        getRootId,
        setOrientation
      }

      const nodeToUpdate = findNodeById(parentId, prevTree)
      if (nodeToUpdate) addNewNode(nodeToUpdate, newChild)

      return { ...prevTree }
    })
  }

  return (
    <FileViewsContext.Provider
      value={{
        ...fileViewsTree,
        setCurrentFile,
        openFile,
        closeFile,
        createChild,
        findNodeById,
        fileViewsTree,
        removeNode,
        setOrientation
      }}
    >
      {children}
    </FileViewsContext.Provider>
  )
}
""""""


File: src/contexts/GuideTourContext.tsx
""""""
import { createContext, useState, useEffect } from 'react'
import Step from 'src/components/Core/GuideTour/Step'
import { ReactourStep } from 'reactour'
import useContextSidebar from 'src/hooks/useSideBar'
import useFileViewsContext from 'src/hooks/useContextFileView'

export type GuideTourContextType = {
  steps: ReactourStep[]
  setTour: (loading: boolean) => void
  isTourOpen: boolean
}

export const GuideTourContext = createContext({} as GuideTourContextType)

export const GuideTourProvider: React.FC = ({ children }) => {
  const { setOpen, setSelectedSection } = useContextSidebar()
  const { openFile } = useFileViewsContext()
  const age = new Date().getFullYear() - 1992
  const totalExperience = new Date().getFullYear() - 2016
  const steps = [
    {
      action: () => {
        setOpen(false)
      },
      content: (
        <Step
          title="Welcome"
          emoticon="❤️"
          content={`Greetings! Welcome to my page, dedicated to my favorite IDE, Visual Studio Code. Let's start our journey!`}
        />
      )
    },
    {
      selector: '[data-tut="profile"]',
      action: () => {
        setOpen(false)
      },
      content: (
        <Step
          title="About Me"
          emoticon="👨‍💻"
          content={`I'm Luís Guilherme, a developer with ${age} years, and more than ${totalExperience} years of experience as Software Engineer specialized in Web Applications. 
          I love physics, cats, and games. Let's dive in!`}
        />
      )
    },
    {
      selector: '[data-tut="nav0"]',
      action: () => {
        setOpen(true)
        setSelectedSection('files')
      },
      content: (
        <Step
          title="File Explorer"
          emoticon="📁"
          content={`Explore the project's file structure here. Everything you need is just a click away.`}
        />
      )
    },
    {
      selector: '[data-tut="resume_folder"]',
      action: () => {
        setOpen(true)
        setSelectedSection('files')
      },
      content: (
        <Step
          title="My Resume"
          emoticon="📔"
          content={`Check out my resume, organized in sections as JSON files or in a single compact YAML file.`}
        />
      )
    },
    {
      selector: '[data-tut="repo_folder"]',
      action: () => {
        setOpen(true)
        setSelectedSection('files')
      },
      content: (
        <Step
          title="Source Code"
          emoticon="💾"
          content={`Here you can review the entire source code of this app. Feel free to explore!`}
        />
      )
    },
    {
      selector: '[data-tut="nav1"]',
      action: () => {
        setOpen(true)
        setSelectedSection('search')
      },
      content: (
        <Step
          title="Search"
          emoticon="🔍"
          content={`Quickly find and replace text across all loaded files using this powerful search feature.`}
        />
      )
    },
    {
      selector: '[data-tut="nav2"]',
      action: () => {
        setOpen(true)
        setSelectedSection('source')
      },
      content: (
        <Step
          title="Source Control"
          emoticon="🔤"
          content={`Track all changes made to files here. Version control made simple.`}
        />
      )
    },
    {
      selector: '[data-tut="nav3"]',
      action: () => {
        setOpen(true)
        setSelectedSection('debug')
      },
      content: (
        <Step
          title="Debug"
          emoticon="⏯️"
          content={`Start debugging your code with a click. Watch random sketch animations to add some fun!`}
        />
      )
    },
    {
      selector: '[data-tut="nav4"]',
      action: () => {
        setOpen(true)
        setSelectedSection('extensions')
      },
      content: (
        <Step
          title="Extensions"
          emoticon="🎬"
          content={`Explore a variety of extensions to enhance your development experience.`}
        />
      )
    },
    {
      selector: '[data-tut="extra0"]',
      action: () => {
        setOpen(false)
        setSelectedSection('files')
      },
      content: (
        <Step
          title="Profile"
          emoticon="🤓"
          content={`Access all my contact information here. You can also download or print my resume as a PDF by pressing CTRL + P`}
        />
      )
    },
    {
      selector: '[data-tut="extra1"]',
      action: () => {
        setOpen(false)
        setSelectedSection('files')
      },
      content: (
        <Step
          title="Settings"
          emoticon="⚙️"
          content={`Customize the theme, open the project on GitHub, star it, or report an issue. Your feedback is valuable!`}
        />
      )
    },
    {
      action: () => {
        setOpen(true)
        setSelectedSection('files')
      },
      content: (
        <Step
          title="Thank You!"
          emoticon="👾"
          content={`Thank you for exploring! Let's connect. May the force be with you!`}
        />
      )
    }
  ]

  const [isTourOpen, setIsTourOpen] = useState(true)

  const setTour = (value: boolean) => {
    setIsTourOpen(value)
    localStorage.setItem('GUIDE_TOUR', JSON.stringify(value))
    if (value === false) {
      openFile('resume/complete-resume.yml', 0)
    }
  }

  useEffect(() => {
    const localStorageGuideTour = localStorage.getItem('GUIDE_TOUR')
    setTour(
      Boolean(
        localStorageGuideTour === null
          ? 'true'
          : localStorageGuideTour === 'true'
      )
    )
  }, [])

  return (
    <GuideTourContext.Provider
      value={{
        setTour,
        isTourOpen,
        steps
      }}
    >
      {children}
    </GuideTourContext.Provider>
  )
}
""""""


File: src/contexts/LoadingContext.tsx
""""""
import { createContext, useState, useCallback } from 'react'
// Removed useAnimationContext import

type Loading = boolean

export type LoadingContextType = {
  loading: Loading
  // Removed flashLoading definition
  setLoading: (loading: boolean) => void
}

export const LoadingContext = createContext({} as LoadingContextType)

export const LoadingProvider: React.FC = ({ children }) => {
  const [loading, setLoadingState] = useState<Loading>(false)
  // Removed AnimationContext usage

  const setLoading = useCallback((isLoading: boolean) => {
    setLoadingState(isLoading)
  }, [])

  // Removed flashLoading function implementation

  return (
    <LoadingContext.Provider
      value={{
        loading,
        // Removed flashLoading from value
        setLoading
      }}
    >
      {children}
    </LoadingContext.Provider>
  )
}
""""""


File: src/contexts/PrintContext.tsx
""""""
import { createContext, useRef } from 'react'
import { useReactToPrint } from 'react-to-print'
import Printable from 'src/components/Core/Printable'
export type PrintContextType = {
  Printable: React.FC
  print: (() => void) | undefined
}

export const PrintContext = createContext({} as PrintContextType)

export const PrintProvider: React.FC = ({ children }) => {
  const printRef = useRef(null)
  const print = useReactToPrint({
    content: () => printRef.current
  })

  const PrintableComponent = () => <Printable printRef={printRef} />

  return (
    <PrintContext.Provider
      value={{
        print,
        Printable: PrintableComponent
      }}
    >
      {children}
    </PrintContext.Provider>
  )
}
""""""


File: src/contexts/README.md
""""""
This directory contains React Context providers responsible for managing global application state.

## Contexts

-   **`FileContext.tsx`**:
    -   **Purpose**: Manages the state of all files (resume data and fetched repository files). This includes their content, modified content (`newContent`), diff status, associated images, and the hierarchical tree structure (`treeFiles`).
    -   **State**: `files` (flat array), `treeFiles` (nested structure), `diffFiles` (filtered array of changed files), `focusedFile`, `focusedFileView`.
    -   **Actions**: Provided via `useReducer` (`fileReducer`) for setting content, images, new content, and replacing the entire file set. Also includes functions to find files within the tree.
    -   **Related**: [Reducers README](../reducers/README.md), [useTree Hook README](../hooks/README.md)
-   **`FileViewContext.tsx`**:
    -   **Purpose**: Manages the state and structure of the editor panes (file views). This allows for multiple, splittable views, each with its own set of opened files and a currently active file.
    -   **State**: A tree structure where each node represents a view pane (`FileViewsContextType`) containing `openedFiles`, `currentFile`, `orientation` (for splitting), `id`, and `children` (representing nested splits).
    -   **Actions**: Functions to `openFile`, `closeFile`, `setCurrentFile`, `createChild` (split view), `removeNode`, `setOrientation`, `findNodeById`.
    -   **Note**: Implements a binary tree structure to manage view layouts. Includes logic for rebalancing the tree when views are closed.
-   **`GuideTourContext.tsx`**:
    -   **Purpose**: Manages the state of the interactive welcome tour (`reactour`).
    -   **State**: `steps` (tour configuration), `isTourOpen` (boolean).
    -   **Actions**: `setTour` function to start/stop the tour and persist the state to `localStorage`.
-   **`LoadingContext.tsx`**:
    -   **Purpose**: Manages the global loading state, primarily used to trigger canvas animations (via `AnimationOverlay`) during operations like fetching file content.
    -   **State**: `loading` (boolean).
    -   **Actions**: `setLoading`.
-   **`PrintContext.tsx`**:
    -   **Purpose**: Provides functionality for printing the resume using `react-to-print`.
    -   **Exports**: `Printable` (the component to be printed, defined in `Core/Printable`), `print` (the function to trigger printing).
-   **`SideBarContext.tsx`**:
    -   **Purpose**: Manages the state of the main sidebar (visibility and selected section).
    -   **State**: `open` (boolean), `selectedSection` (e.g., 'files', 'search').
    -   **Actions**: `setOpen`, `setSelectedSection`.
-   **`ThemeContext.tsx`**:
    -   **Purpose**: Manages the application's color theme (light/dark).
    -   **State**: `selectedTheme` ('light' | 'vs-dark').
    -   **Actions**: `toggleTheme` function to switch themes and persist the choice to `localStorage`.
    -   **Related**: [Styles README](../styles/README.md)

## Usage

Components typically consume context values using the corresponding custom hooks (e.g., `useContextFile`, `useContextTheme`) defined in `src/hooks/`.

## Related READMEs

-   [Hooks README](../hooks/README.md)
-   [Reducers README](../reducers/README.md)
-   [Root README](../../README.md)
""""""


File: src/contexts/SideBarContext.tsx
""""""
import { createContext, useState } from 'react'

type SelectedSectionType =
  | 'files'
  | 'search'
  | 'source'
  | 'debug'
  | 'extensions'
  | 'profile'
  | 'settings'

export type SideBasContextType = {
  open: boolean
  selectedSection: SelectedSectionType
  setOpen: (bool: boolean) => void
  setSelectedSection: (selectedSection: SelectedSectionType) => void
}

export const SideBarContext = createContext({} as SideBasContextType)

export const SideBarProvider: React.FC = ({ children }) => {
  const [open, setOpen] = useState<boolean>(false)
  const [selectedSection, setSelectedSection] =
    useState<SelectedSectionType>('files')

  return (
    <SideBarContext.Provider
      value={{
        selectedSection,
        setSelectedSection,
        open,
        setOpen
      }}
    >
      {children}
    </SideBarContext.Provider>
  )
}
""""""


File: src/contexts/ThemeContext.tsx
""""""
import { createContext, useState, useEffect } from 'react'

type SelectedThemeType = 'light' | 'vs-dark'

export type ThemeContextType = {
  selectedTheme: SelectedThemeType
  toggleTheme: () => void
}

export const ThemeContext = createContext({} as ThemeContextType)

export const UIProvider: React.FC = ({ children }) => {
  const [selectedTheme, setTheme] = useState<SelectedThemeType>('vs-dark')

  const toggleTheme = () => {
    const newTheme = selectedTheme === 'light' ? 'vs-dark' : 'light'
    localStorage.setItem('THEME', newTheme)
    setTheme(newTheme)
  }

  useEffect(() => {
    const localStorageTheme = localStorage.getItem('THEME') as SelectedThemeType
    const theme: SelectedThemeType = localStorageTheme || 'vs-dark'
    theme && setTheme(theme)
  }, [])

  return (
    <ThemeContext.Provider
      value={{
        selectedTheme,
        toggleTheme
      }}
    >
      {children}
    </ThemeContext.Provider>
  )
}
""""""


File: src/contexts/getResumeFiles.tsx
""""""
import YAML from 'yaml'
import education from 'src/assets/education'
import experiences from 'src/assets/experiences'
import coverLetter from 'src/assets/coverLetter'
import contacts from 'src/assets/contacts'
import skills from 'src/assets/skills'
import projects from 'src/assets/projects'

export const getResumeData = (): {
  path: string
  name: string
  content: string
  newContent: string
}[] => {
  const coverLetterText = JSON.stringify(coverLetter.join(''), null, 2)
  const skillsText = JSON.stringify(skills, null, 2)
  const educationText = JSON.stringify(education, null, 2)
  const experiencesText = JSON.stringify(experiences, null, 2)
  const contactsText = JSON.stringify(contacts, null, 2)
  const projectsText = JSON.stringify(projects, null, 2)

  const completeResumeText = YAML.stringify({
    'Cover Letter': coverLetter.join(''),
    Contacts: contacts,
    Education: education,
    Experiences: experiences,
    Skills: skills,
    Projects: projects
  })
    .replace(
      /(Projects:|Education:|Experiences:|Contacts:|- Company:|- name:|- title:|- School:|Skills:|- Languages:|- Programming Languages:|- Development Tools:|- Testing\/QA:|- Front-end:|- Back-end:|- Cloud\/Infrastructure:)/g,
      '\n$&'
    )
    .replace(/(Cover Letter:|Contacts:|Projects:)/g, '$&\n')
    .replace(/Cover Letter:/, '$&\n')

  return [
    {
      path: 'resume/cover-letter.json',
      name: 'cover-letter.json',
      content: coverLetterText,
      newContent: coverLetterText
    },
    {
      path: 'resume/education.json',
      name: 'education.json',
      content: educationText,
      newContent: educationText
    },
    {
      path: 'resume/experience.json',
      name: 'experience.json',
      content: experiencesText,
      newContent: experiencesText
    },
    {
      path: 'resume/skills.json',
      name: 'skills.json',
      content: skillsText,
      newContent: skillsText
    },
    {
      path: 'resume/contacts.json',
      name: 'contacts.json',
      content: contactsText,
      newContent: contactsText
    },
    {
      path: 'resume/projects.json',
      name: 'projects.json',
      content: projectsText,
      newContent: projectsText
    },
    {
      path: 'resume/complete-resume.yml',
      name: 'complete-resume.yml',
      content: completeResumeText,
      newContent: completeResumeText
    }
  ]
}
""""""


File: src/hooks/README.md
""""""
This directory contains various P5.js sketches used for animations within the application, primarily for loading indicators and the "Extensions" demonstration panel.

## Structure

-   **`index.ts`**: Exports an array of all available sketch *factories* and a `sketchs` array containing metadata (name, description, icon) for each sketch, used by the UI (e.g., Extensions panel).
-   **Individual Sketch Directories (e.g., `Bouncing/`, `SnowFlakes/`, `DoublePendulum/`)**: Each directory typically contains an `index.ts` file that defines and exports a single sketch factory function.

## Sketch Factory

Each sketch is defined as a *factory function* that takes the current theme object as an argument and returns the actual P5.js sketch function. This allows sketches to adapt their appearance (e.g., colors) based on the selected theme.

The signature is:
`(theme: Theme) => (p5: P5) => void`

The inner function `(p5: P5) => void` is the standard P5.js instance mode setup, containing `setup` and `draw` methods.

## Available Sketches

-   **Bouncing**: Multiple particles bouncing off the canvas edges.
-   **LinearConservation**: A single particle bouncing with gravity, demonstrating basic physics.
-   **RandomWalker**: A single particle moving randomly.
-   **SnowFlakes**: Particles simulating falling snowflakes.
-   **DoublePendulum**: Simulates the chaotic motion of a double pendulum with a tracing effect.
-   **HexagonCollision**: Features spinning hexagons (with a missing edge) releasing triangles that undergo elastic collisions.
-   **Starfield**: Creates a visual effect simulating high-speed travel through space (like Star Wars hyperdrive).
-   **PathfindingMaze**: Generates a random maze and visualizes the A* pathfinding algorithm finding a route.
-   **Hypercube**: Renders a rotating 4-dimensional hypercube (tesseract) projected into 3D/2D space.
-   **GoogleFlowField**: Particles follow paths defined by a Perlin noise field, colored using the Google palette.
-   **BoidsSimulation**: Simulates flocking behavior (separation, alignment, cohesion) among agents (boids) using Google colors.
-   **GameOfLife**: Implements Conway's Game of Life cellular automaton using Google colors.
-   **Metaballs**: Creates an organic, "gooey" visual effect where circular shapes merge smoothly, using Google colors.
-   **FourierDrawing**: Visualizes Fourier series by drawing complex shapes using rotating vectors (epicycles).
-   **ReactionDiffusion**: Simulates the formation of complex patterns based on the interaction of two chemicals (Turing patterns).

## Adding New Sketches

1.  Create a new directory (e.g., `MyNewSketch/`).
2.  Inside, create `index.ts`.
3.  Define your sketch factory function following the signature `(theme: Theme) => (p5: P5) => void`. Use the `theme` object to access colors if needed. Import `Body` and `Calculator` from `../Engine` if physics simulation is required.
4.  Export the factory function as default from `MyNewSketch/index.ts`.
5.  Import the new sketch factory into `src/components/Core/Sketchs/index.ts`.
6.  Add the new factory to the default export array.
7.  Add metadata (name, description, icon path) for the new sketch to the `sketchs` array in `src/components/Core/Sketchs/index.ts`. Remember to create a corresponding icon in `public/icons/`.

## Usage

Sketches are primarily rendered using the `AnimationOverlay` component (`src/components/Core/AnimationOverlay/index.tsx`), which handles dynamic loading, P5.js instance creation, display in a modal, and cleanup. The `Loading` component and the `Extensions` panel in the `SideBar` trigger the `AnimationOverlay`. The `Canvas` component (`src/components/Core/Canvas/index.tsx`) can still be used for embedding sketches directly within other components if needed.

## Related READMEs

-   [Core Components README](../README.md)
-   [Engine README](../Engine/README.md)
-   [Root README](../../../../README.md)
""""""


File: src/hooks/useContextFile.ts
""""""
import { useContext } from 'react'
import { FileContext, FileContextType } from 'src/contexts/FileContext'

export const useContextFile = (): FileContextType => {
  const file = useContext(FileContext)
  return file
}

export default useContextFile
""""""


File: src/hooks/useContextFileView.ts
""""""
import { useContext } from 'react'
import {
  FileViewsContext,
  FileViewsContextType
} from 'src/contexts/FileViewContext'

export const useFileViewsContext = (): FileViewsContextType => {
  const fileViewsContext = useContext(FileViewsContext)
  return fileViewsContext
}

export default useFileViewsContext
""""""


File: src/hooks/useContextPrint.ts
""""""
import { useContext } from 'react'
import { PrintContextType, PrintContext } from 'src/contexts/PrintContext'

export const useContextPrint = (): PrintContextType => {
  const print = useContext(PrintContext)
  return print
}

export default useContextPrint
""""""


File: src/hooks/useContextTheme.ts
""""""
import { useContext } from 'react'
import { ThemeContext, ThemeContextType } from 'src/contexts/ThemeContext'

export const useContextTheme = (): ThemeContextType => {
  const EditorTheme = useContext(ThemeContext)
  return EditorTheme
}

export default useContextTheme
""""""


File: src/hooks/useExtension.ts
""""""
import TypescriptIcon from 'public/icons/typescript.svg'
import TypescriptAltIcon from 'public/icons/typescript-outlined.svg'
import EslintIcon from 'public/icons/eslint.svg'
import BabelIcon from 'public/icons/babel.svg'
import ImageIcon from 'public/icons/file-image-solid.svg'
import FolderIcon from 'public/icons/folder-solid.svg'
import OpenFolderIcon from 'public/icons/folder-open-solid.svg'
import GitIcon from 'public/icons/git-icon.svg'
import JSONIcon from 'public/icons/json.svg'
import JavascriptIcon from 'public/icons/javascript.svg'
import PrettierIcon from 'public/icons/prettier.svg'
import ReactIcon from 'public/icons/react.svg'
import YarnIcon from 'public/icons/yarn.svg'
import YamlIcon from 'public/icons/yaml.svg'
import NodeIcon from 'public/icons/nodejs.svg'
import FileIcon from 'public/icons/file.svg'
import React from 'react'
import useContextFile from './useContextFile'

export type useExtension = {
  extractIcon: (
    file: string,
    open: boolean,
    folder: boolean
  ) => React.FC<{ height: string; width: string }>
  extractExtension: (file: string) => string
}

export const useExtension = (): useExtension => {
  const extractExtension = (file: string): string => {
    const splittedPath = file?.split('.')
    const ext = !!splittedPath?.length && splittedPath[splittedPath.length - 1]

    const languages = [
      {
        name: 'json',
        regex: /lock|json/
      },
      {
        name: 'javascript',
        regex: /js/
      },
      {
        name: 'typescript',
        regex: /ts/
      },
      {
        name: 'yaml',
        regex: /editorconfig|Dockerfile|yaml|yml|gitignore/
      },
      {
        name: 'markdown',
        regex: /\.md/
      },
      {
        name: 'html',
        regex: /html/
      },
      {
        name: 'xml',
        regex: /xml|svg/
      }
    ]

    const selectedLanguage =
      languages.find(({ regex }) => ext && ext.match(regex))?.name || 'json'

    return selectedLanguage
  }

  const extractIcon = (
    path: string,
    open: boolean,
    folder: boolean
  ): React.FC => {
    const { files } = useContextFile()
    const file = files.find(file => file.path === path)
    const icons = [
      { expression: /.png|.jpg|.jpeg|.svg|.ico/, icon: ImageIcon },
      { expression: 'package.json', icon: NodeIcon },
      { expression: 'git', icon: GitIcon },
      { expression: 'eslint', icon: EslintIcon },
      { expression: 'babel', icon: BabelIcon },
      { expression: 'yarn', icon: YarnIcon },
      { expression: 'prettier', icon: PrettierIcon },
      { expression: '.d.ts', icon: TypescriptAltIcon },
      { expression: '.json', icon: JSONIcon },
      { expression: /.(t|j)sx/, icon: ReactIcon },
      { expression: '.js', icon: JavascriptIcon },
      { expression: '.ts', icon: TypescriptIcon },
      { expression: /.yml|.yaml/, icon: YamlIcon },
      { expression: /./, icon: FileIcon },
      { expression: /./, icon: OpenFolderIcon },
      { expression: /./, icon: FolderIcon }
    ]

    const IconByExtensionMatch = icons.find(({ expression }) =>
      file?.name?.match(expression)
    )

    const selectedIcon = folder
      ? open
        ? OpenFolderIcon
        : FolderIcon
      : IconByExtensionMatch?.icon

    return selectedIcon || FileIcon
  }
  return { extractExtension, extractIcon }
}

export default useExtension
""""""


File: src/hooks/useGuideTour.ts
""""""
import { useContext } from 'react'
import {
  GuideTourContextType,
  GuideTourContext
} from 'src/contexts/GuideTourContext'

export const useContextGuideTour = (): GuideTourContextType => {
  const guideTour = useContext(GuideTourContext)
  return guideTour
}

export default useContextGuideTour
""""""


File: src/hooks/useLoading.ts
""""""
import { useContext } from 'react'
import { LoadingContextType, LoadingContext } from 'src/contexts/LoadingContext'

export const useContextLoading = (): LoadingContextType => {
  const loading = useContext(LoadingContext)
  return loading
}

export default useContextLoading
""""""


File: src/hooks/useSideBar.ts
""""""
import { useContext } from 'react'
import { SideBarContext, SideBasContextType } from 'src/contexts/SideBarContext'

export const useContextSidebar = (): SideBasContextType => {
  const SideBar = useContext(SideBarContext)
  return SideBar
}

export default useContextSidebar
""""""


File: src/hooks/useTree.ts
""""""
import { FileType } from 'src/contexts/FileContext'

type NodeTree = {
  path: string
  mode?: string
  type?: string
  sha?: string
  size?: number
  url?: string
}

export const useTree = (): {
  build: (
    files: NodeTree[],
    depth?: number,
    containDirectory?: string
  ) => FileType[]
  rebuildPaths: (
    files: NodeTree[],
    depth?: number,
    containDirectory?: string
  ) => FileType[]
  flatTree: (tree: FileType[]) => FileType[]
} => {
  const build = (
    files: NodeTree[],
    depth = 1,
    containDirectory = ''
  ): NodeTree[] => {
    const fileToCreate = files.filter(file => {
      const currentDepth = file.path.split('/').length
      const penultimatePath = file.path.split('/')[currentDepth - 2]

      return (
        currentDepth === depth &&
        (!containDirectory || containDirectory === penultimatePath)
      )
    })

    if (fileToCreate.length) {
      return fileToCreate.map((file: NodeTree) => {
        const splittedPath = file.path.split('/')
        const name = splittedPath[depth - 1].replace('__working__tree__', '')
        const newNode = {
          ...file,
          name,
          children:
            name === process.env.REPO || !name.includes('.')
              ? build(files, depth + 1, name)
              : []
        }
        return newNode
      })
    } else {
      return []
    }
  }

  const rebuildPaths = (array: FileType[]): FileType[] => {
    const splittedDiffFiles: FileType[] = array.map(_ => _)
    array.forEach(diffFile => {
      const createSubPaths = (path: string) => {
        const slicedPath = path.split('/')
        slicedPath.splice(-1)

        if (slicedPath) {
          const newPathToCreate = slicedPath.join('/')
          const pathToCreateAlreadyExist = !!splittedDiffFiles.find(
            diff => diff?.path === newPathToCreate
          )
          newPathToCreate &&
            !pathToCreateAlreadyExist &&
            splittedDiffFiles.push({ path: newPathToCreate })
          if (typeof slicedPath !== 'string' && slicedPath.length > 1) {
            createSubPaths(newPathToCreate)
          }
        }
      }

      createSubPaths(diffFile.path)
    })
    return splittedDiffFiles
  }

  const flatTree = (tree: FileType[]): FileType[] => {
    const rawFlattedTree: FileType[] = []
    const flatADepth = (tree: FileType[]) => {
      tree.forEach(node => {
        const { children } = node
        rawFlattedTree.push(node)
        if (children?.length) {
          flatADepth(children)
        }
      })
    }
    flatADepth(tree)

    const flattedTree: FileType[] = rawFlattedTree.map(
      ({ path, name, content, newContent }) => ({
        path,
        name,
        content,
        newContent
      })
    )

    return flattedTree
  }
  return { build, rebuildPaths, flatTree }
}

export default useTree
""""""


File: src/hooks/useWindow.ts
""""""
import { useState, useEffect, useCallback } from 'react'
import { Theme } from 'src/styles/styled'
import rawTheme from 'src/styles/theme'
import useContextTheme from './useContextTheme'

type WindowSizeType = {
  width?: number
  height?: number
}

type useWindowContext = {
  width?: number
  height?: number
  isXSmall: boolean
  isSmall: boolean
  isMedium: boolean
}

export const useWindowSize = (): useWindowContext => {
  const { selectedTheme } = useContextTheme()
  const theme: Theme = rawTheme[selectedTheme]

  const [windowSize, setWindowSize] = useState<WindowSizeType>({
    width: undefined,
    height: undefined
  })

  const handleResize = useCallback(() => {
    if (window !== undefined) {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      })
    }
  }, [])

  useEffect(() => {
    window.addEventListener('resize', handleResize)
    handleResize()
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  const breakpointsEntries = Object.entries(theme.breakpoints).map(
    ([key, value]) => [key, parseInt(value.replace('px', ''))]
  )

  const breakpoints = Object.fromEntries(breakpointsEntries)
  const currentWidth = windowSize?.width || 0
  const isXSmall = currentWidth < breakpoints.xSmall
  const isSmall = currentWidth < breakpoints.small
  const isMedium = currentWidth < breakpoints.medium

  return {
    ...windowSize,
    isXSmall,
    isSmall,
    isMedium
  }
}

export default useWindowSize
""""""


File: src/pages/_app.tsx
""""""
'use client'
import type { AppProps } from 'next/app'
import dynamic from 'next/dynamic'
import { FileProvider } from 'src/contexts/FileContext'
import { UIProvider } from 'src/contexts/ThemeContext'
import { PrintProvider } from 'src/contexts/PrintContext'
import Shell from 'src/components/Core/Shell'
import GlobalStyle from 'src/styles/global'
import { SideBarProvider } from 'src/contexts/SideBarContext'
import { FileViewsProvider } from 'src/contexts/FileViewContext'
import { LoadingProvider } from 'src/contexts/LoadingContext'
import { GuideTourProvider } from 'src/contexts/GuideTourContext'
import { Analytics } from '@vercel/analytics/react'
import P5Preloader from 'src/components/Core/P5Preloader' // Import the preloader

const MyApp: React.FC<AppProps> = ({ Component, pageProps }) => {
  return (
    <>
      <GlobalStyle />
      <UIProvider>
        <SideBarProvider>
          <FileProvider>
            <FileViewsProvider initialOpenedFile={'resume/complete-resume.yml'}>
              <PrintProvider>
                <LoadingProvider>
                  <GuideTourProvider>
                    <Shell>
                      <P5Preloader /> {/* Add Preloader here */}
                      <Component {...pageProps} />
                      <Analytics />
                    </Shell>
                  </GuideTourProvider>
                </LoadingProvider>
              </PrintProvider>
            </FileViewsProvider>
          </FileProvider>
        </SideBarProvider>
      </UIProvider>
    </>
  )
}
export default MyApp
""""""


File: src/pages/_document.tsx
""""""
import Document, {
  DocumentContext,
  DocumentInitialProps,
  Html,
  Head,
  Main,
  NextScript
} from 'next/document'

import { ServerStyleSheet } from 'styled-components'

export default class MyDocument extends Document {
  render(): JSX.Element {
    return (
      <Html lang="en">
        <Head>
          <link rel="shortcut icon" href="/favicon.ico" />
          <meta name="description" content="Luis Guilherme Page" />
          <meta charSet="utf-8" />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    )
  }

  static async getInitialProps(
    ctx: DocumentContext
  ): Promise<DocumentInitialProps> {
    const sheet = new ServerStyleSheet()
    const originalRenderPage = ctx.renderPage

    try {
      ctx.renderPage = () =>
        originalRenderPage({
          enhanceApp: App => props => sheet.collectStyles(<App {...props} />)
        })

      const initialProps = await Document.getInitialProps(ctx)
      return {
        ...initialProps,
        styles: (
          <>
            {initialProps.styles}
            {sheet.getStyleElement()}
          </>
        )
      }
    } finally {
      sheet.seal()
    }
  }
}
""""""


File: src/pages/index.tsx
""""""
import type { NextPage } from 'next'

import { LoadingProvider } from 'src/contexts/LoadingContext'
import { GuideTourProvider } from 'src/contexts/GuideTourContext'

import HomeView from 'src/components/Home'
const Home: NextPage = () => {
  return (
    <LoadingProvider>
      <GuideTourProvider>
        <title>Luís Guilherme</title>
        <meta name="description" content="Luis Guilherme Webpage" />
        <div>
          <HomeView />
        </div>
      </GuideTourProvider>
    </LoadingProvider>
  )
}

export default Home
""""""


File: src/reducers/FileReducer.tsx
""""""
export type FileType = {
  name?: string
  content?: string
  newContent?: string
  path: string
  open?: boolean
  highLighted?: boolean
  current?: boolean
  image?: JSX.Element
  children?: FileType[]
  index?: number
  diff?: boolean
  isDiff?: boolean
}

type SingleTargetAction = {
  type:
    | 'SET_CURRENT'
    | 'CLEAN_CURRENT'
    | 'SET_HIGHLIGHTED'
    | 'CLEAN_HIGHLIGHTED'
    | 'SET_IMAGE'
    | 'SET_CONTENT'
    | 'SET_NEW_CONTENT'

  payload: FileType
}

type MultipleTargetAction = { type: 'SET_FILES'; payload: FileType[] }

export type ActionType = SingleTargetAction | MultipleTargetAction

const fileReducer = (state: FileType[], action: ActionType): FileType[] => {
  switch (action.type) {
    case 'SET_CURRENT':
      return state.map(file => ({
        ...file,
        current: action?.payload?.path === file?.path,
        highLighted: action?.payload?.path === file?.path
      }))
    case 'CLEAN_CURRENT':
      return state.map(file => ({
        ...file,
        current: false,
        highLighted: false
      }))

    case 'SET_HIGHLIGHTED':
      return state.map(file => ({
        ...file,
        highLighted: action?.payload?.path === file?.path
      }))
    case 'CLEAN_HIGHLIGHTED':
      return state.map(file => ({
        ...file,
        highLighted: false
      }))
    case 'SET_IMAGE':
      return state.map(file => ({
        ...file,
        image:
          file?.path === action.payload.path
            ? action.payload.image
            : file?.image
      }))

    case 'SET_CONTENT':
      return state.map(file => ({
        ...file,
        content:
          file?.path.replace('__working__tree__', '') ===
          action.payload.path.replace('__working__tree__', '')
            ? action.payload.content
            : file?.content,
        newContent:
          file?.path.replace('__working__tree__', '') ===
          action.payload.path.replace('__working__tree__', '')
            ? action.payload.content
            : file?.newContent
      }))
    case 'SET_NEW_CONTENT': {
      return state.map(file => ({
        ...file,
        diff:
          file?.path.replace('__working__tree__', '') ===
          action.payload.path.replace('__working__tree__', '')
            ? !!(file.content !== action.payload.newContent)
            : file.diff,
        newContent:
          file?.path.replace('__working__tree__', '') ===
          action.payload.path.replace('__working__tree__', '')
            ? action.payload.newContent
            : file?.newContent
      }))
    }

    case 'SET_FILES':
      return action.payload

    default:
      return state
  }
}

export default fileReducer
""""""


File: src/reducers/README.md
""""""

This directory contains reducer functions used with the `useReducer` hook for managing complex state logic, primarily for the `FileContext`.

## Reducers

-   **`FileReducer.tsx`**: Manages the state of the `files` array within `FileContext`.
    -   **State (`FileType[]`)**: An array where each object represents a file and contains properties like `path`, `name`, `content`, `newContent`, `image`, `diff`, `isDiff`, etc.
    -   **Actions (`ActionType`)**: Handles various actions to update the file state:
        -   `SET_CURRENT`: Marks a specific file as the currently active one (unused, handled by `FileViewContext`).
        -   `CLEAN_CURRENT`: Clears the current file flag (unused).
        -   `SET_HIGHLIGHTED`: Marks a file as highlighted (unused, handled by `FileViewContext` or component state).
        -   `CLEAN_HIGHLIGHTED`: Clears the highlighted flag (unused).
        -   `SET_IMAGE`: Updates the `image` property (JSX element) for a specific file.
        -   `SET_CONTENT`: Sets the initial `content` and `newContent` for a file (typically after fetching).
        -   `SET_NEW_CONTENT`: Updates the `newContent` of a file and sets the `diff` flag if `newContent` differs from `content`.
        -   `SET_FILES`: Replaces the entire state with a new array of files.

## Usage

The `FileReducer` is used within `FileContext.tsx` like this:
`const [files, dispatch] = useReducer(fileReducer, initialState);`

Actions are dispatched from `FileContext`'s exported functions (e.g., `setContent`, `setNewContent`).

## Related READMEs

-   [Contexts README](../contexts/README.md)
-   [Root README](../../README.md)
""""""


File: src/services/README.md
""""""

This directory contains modules responsible for interacting with external services or APIs.

## Services

-   **`github/index.ts`**: Handles communication with the GitHub REST API.
    -   **`fetchFileContent(path)`**: Fetches the content of a specific file from the repository defined by environment variables (`OWNER`, `REPO`, `SHA_BRANCH`). Returns the base64 encoded content.
    -   **`fetchRepoTree()`**: Fetches the entire file tree structure of the repository recursively for the specified branch (`SHA_BRANCH`). Returns a flat array of file/directory objects.

## Configuration

The GitHub service relies on the following environment variables set in `next.config.js`:

-   `REPO`: The name of the GitHub repository (e.g., 'luisguilher.me').
-   `OWNER`: The owner of the GitHub repository (e.g., 'lguibr').
-   `SHA_BRANCH`: The branch or commit SHA to fetch data from (e.g., 'main').

## Usage

Import the service (e.g., `import githubService from 'src/services/github'`) and call its methods. These are typically used within contexts (`FileContext`) or potentially custom hooks to fetch initial data or file content on demand.

## Related READMEs

-   [Contexts README](../contexts/README.md)
-   [Root README](../../README.md)
""""""


File: src/services/github/index.ts
""""""
const branchSha = process.env.SHA_BRANCH
const repo = process.env.REPO
const owner = process.env.OWNER

type ResTreeFilesType = {
  path: string
  mode?: string
  type?: string
  sha?: string
  size?: number
  url?: string
}
type ResFileType = {
  content: string
}

const githubService = {
  fetchFileContent: async (path: string): Promise<ResFileType> => {
    const filePath = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branchSha}`
    const res = await fetch(filePath)
    const data = await res.json()
    return data
  },
  fetchRepoTree: async (): Promise<ResTreeFilesType[]> => {
    const threePath = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branchSha}?recursive=1`
    const res = await fetch(threePath)
    const data = await res.json()
    const rawTree = data.tree
    return rawTree
  }
}

export default githubService
""""""


File: src/styles/README.md
""""""

This directory manages the application's styling, theming, and related type definitions.

## Files

-   **`global.ts`**: Defines global CSS styles using `styled-components`' `createGlobalStyle`. Includes resets, base font settings, and scrollbar styling.
-   **`theme.ts`**: Defines the color palettes and breakpoint values for the different themes ('light', 'vs-dark'). This object is used by the `ThemeProvider` in `src/components/Core/Shell.tsx`.
-   **`styled.d.ts`**: TypeScript declaration file for `styled-components`. It extends the `DefaultTheme` interface to provide type safety and autocompletion when accessing theme properties within styled components (e.g., `theme.colors.text`).

## Approach

-   **Styled Components**: Used for component-level styling, allowing CSS to be co-located with component logic and enabling dynamic styling based on props and theme.
-   **Theming**: `ThemeProvider` wraps the application (`Shell`), providing the selected theme object (`light` or `vs-dark`) to all styled components via the `theme` prop. Theme switching is handled by `ThemeContext`.
-   **Breakpoints**: Defined in `theme.ts` and used within styled components for responsive design via media queries (e.g., `@media (max-width: ${({ theme }) => theme.breakpoints.medium})`). Custom hooks like `useWindowSize` also utilize these breakpoints.

## Usage

-   Styled components access theme variables like: `color: ${({ theme }) => theme.colors.text};`
-   Global styles are applied automatically.
-   Theme switching is managed by `ThemeContext` and `useContextTheme` hook.

## Related READMEs

-   [Contexts README](../contexts/README.md)
-   [Hooks README](../hooks/README.md)
-   [Root README](../../README.md)
""""""


File: src/styles/global.ts
""""""
import { createGlobalStyle } from 'styled-components'

export default createGlobalStyle`

  * {
    margin : 0px;
    padding : 0px;
    -webkit-tap-highlight-color: transparent;


    ::-webkit-scrollbar {
      width: 8px;
      height: 4px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #515151;
    }

    ::-webkit-scrollbar-thumb:active {
      background: #662e2a;
    }
  }

  body {
    color: white;
    font: 400 16px sans-serif;
    overflow:hidden;
    min-height: 100vh;
  }
`
""""""


File: src/styles/styled.d.ts
""""""
/* eslint @typescript-eslint/no-empty-interface: "off" */
import 'styled-components'
import theme from 'src/styles/theme'

export type Theme = typeof theme['vs-dark']

declare module 'styled-components' {
  export interface DefaultTheme extends Theme {}
}
""""""


File: src/styles/theme.ts
""""""
const breakpoints = {
  xSmall: '480px',
  small: '768px',
  medium: '1024px',
  large: '1280px',
  xLarge: '1600px'
}

export default {
  light: {
    colors: {
      editorBackground: '#FFFFFF',
      text: '#616161',
      menuBackground: '#F3F3F3',
      listDropBackground: '#2C2C2C',
      topBarBackground: '#E5E5E5',
      sideHighlight: '#E8E8E8',
      sideHighlightHover: '#EFFFFF',
      tileBorder: '#EFFFFF',
      negativeHighlight: '#f4f4f4',
      accentColor: '#F44336',
      navigationFile: '#ECECEC',
      selectedNavigationFile: '#FFFFFF',
      fileLine: '#CFCFCF',
      queryString: '#F0C1A3',
      inputBackground: '#FFF',
      selectedBlue: '#CCE9FC',
      subString: '#99999A',
      vsBlue: '#1E88D0',
      white: '#FFF',
      black: '#000',
      shortCut: '#F3F3F3'
    },
    breakpoints
  },
  'vs-dark': {
    colors: {
      editorBackground: '#1E1E1E',
      menuBackground: '#252526',
      listDropBackground: '#333333',
      topBarBackground: '#323233',
      text: '#CCCCCC',
      sideHighlight: '#37373D',
      sideHighlightHover: '#242d2e',
      tileBorder: '#111111',
      negativeHighlight: '#303131',
      accentColor: '#F44336',
      navigationFile: '#252526',
      selectedNavigationFile: '#1E1E1E',
      fileLine: '#585858',
      queryString: '#66371A',
      inputBackground: '#3C3C3C',
      selectedBlue: '#245779',
      subString: '#99999A',
      vsBlue: '#1E88D0',
      white: '#FFF',
      black: '#000',
      shortCut: '#2B2B2B'
    },
    breakpoints
  }
}
""""""


File: tsconfig.json
""""""
{
  "compilerOptions": {
    "target": "esnext",
    "baseUrl": ".",
    "module": "esnext",
    "jsx": "preserve",
    "lib": [
      "dom",
      "es2017"
    ],
    "moduleResolution": "node",
    "allowJs": true,
    "noEmit": true,
    "strict": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "sourceMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true
  },
  "exclude": [
    "node_modules",
    "**/*.md" // Corrected pattern
  ],
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ]
}
""""""


